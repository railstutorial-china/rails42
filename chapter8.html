<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <title>Ruby on Rails 教程 - 第 8 章 登录和退出</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="最好的 Ruby on Rails 入门教程"/>
    <meta name="keywords" content="ruby, rails, tutorial"/>
    <meta name="author" content="Michael Hartl"/>
    <meta name="translator" content="安道"/>
    <meta name="generator" content="persie 0.0.1.alpha.5"/>
    <link rel="stylesheet" type="text/css" href="http://cdn.staticfile.org/twitter-bootstrap/3.2.0/css/bootstrap.min.css"/>
    <link rel="stylesheet" type="text/css" href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" type="text/css" href="assets/style.css"/>
    <script type="text/javascript" src="http://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/twitter-bootstrap/3.2.0/js/collapse.min.js"></script>
    <script type="text/javascript" src="assets/global.js"></script>
</head>
<body>

<header class="navbar navbar-default navbar-fixed-top navbar-book">
    <div class="container">
        <div class="navbar-header">
            <a href="http://railstutorial-china.org" class="navbar-brand">Ruby on Rails 教程</a>
            <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".book-navbar-collapse">
                <span class="sr-only">导航</span>
                <i class="fa fa-bars"></i>
            </button>
            <a href="http://railstutorial-china.org/#purchase" id="navbar-purchase-xs" class="btn btn-warning navbar-btn visible-xs collapsed-purchase-btn">购买</a>
        </div>
        <nav class="collapse navbar-collapse book-navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li><a href="http://railstutorial-china.org" title="首页">首页</a></li>
                <li class="active"><a href="http://railstutorial-china.org/read/" title="在线阅读">阅读</a></li>
                <li><a href="http://railstutorial-china.org/blog/" title="最新消息">博客</a></li>
                <li><a href="https://selfstore.io/products/189/topics" title="论坛">论坛</a></li>
                <li class="hidden-xs"><div><a href="http://railstutorial-china.org/#purchase" id="navbar-purchase" class="btn btn-warning navbar-btn" title="购买电子书">购买</a></div></li>
            </ul>
        </nav>
    </div>
</header>

<div class="content">
    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8">
                <article class="article">
                    <section data-type="chapter" id="log-in-log-out">
<h1><span class="title-label">第 8 章</span> 登录和退出</h1>
<p><a href="chapter7.html#sign-up">第 7 章</a>实现了用户注册功能，本章要实现登录和退出功能。我们要通过网络中三种常见的方式实现登录退出功能，分别为：浏览器关闭后“忘记”用户的登录状态（<a href="#sessions">8.1 节</a>和 <a href="#logging-in">8.2 节</a>），自动记住用户的登录状态（<a href="#remember-me">8.4 节</a>），勾选“记住我”选项时才记住用户的登录状态（<a href="#remember-me-checkbox">8.4.5 节</a>）。<sup>[<a id="fn-ref-1" href="#fn-1">1</a>]</sup></p>
<p>本章开发的认证系统可用于定制网站的内容，还能基于登录状态和用户的身份实现权限机制。例如，本章我们会更新网站的头部，加入“登录”或“退出”链接，以及到个人资料页面的链接。<a href="chapter9.html#updating-showing-and-deleting-users">第 9 章</a>会实现一种安全机制，只有已登录的用户才能访问用户列表页面，只有用户自己才能编辑自己的信息，只有管理员才能从数据库中删除其他用户。<a href="chapter11.html#user-microposts">[chapter11#user-microposts]</a>会使用已登录用户的身份发布他自己的微博。<a href="chapter12.html#following-users">[chapter12#following-users]</a>会让当前登录的用户关注网站中的其他用户，从而获取关注用户的微博更新。</p>
<section data-type="sect1" id="sessions">
<h1><span class="title-label">8.1</span> 会话</h1>
<p><a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> 协议<a href="https://en.wikipedia.org/wiki/Stateless_protocol">没有状态</a>，每个请求都是独立的事务，无法使用之前请求中的信息。所以，在 HTTP 协议中无法在两个页面之间记住用户的身份。需要用户登录的应用都要使用“<a href="http://en.wikipedia.org/wiki/Session_(computer_science)">会话</a>”（session）。会话是两台电脑之间的半永久性连接，例如运行 Web 浏览器的客户端电脑和运行 Rails 的服务器。</p>
<p>在 Rails 中实现会话最常见的方式是使用 <a href="http://en.wikipedia.org/wiki/HTTP_cookie">cookie</a>。cookie 是存储在用户浏览器中的少量文本。访问其他页面时，cookie 中存储的信息仍在，所以可以在 cookie 中存储一些信息，例如用户的 ID，让应用从数据库中取回已登录的用户。这一节和 <a href="#logging-in">8.2 节</a>会使用 Rails 提供的 <code>session</code> 方法实现临时会话，浏览器关闭后会话自动失效。<sup>[<a id="fn-ref-2" href="#fn-2">2</a>]</sup><a href="#remember-me">8.4 节</a>会使用 Rails 提供的 <code>cookies</code> 方法让会话持续的时间久一些。</p>
<p>把会话看成符合 REST 架构的资源便于操作，访问登录页面时渲染一个表单用于新建会话，登录时创建一个会话，退出时再把会话销毁。不过会话和用户资源不同，用户资源（通过用户模型）使用数据库存储数据，而会话资源要使用 cookie。所以，登录功能的大部分工作是实现基于会话的认证机制。这一节和下一节要为登录功能做些准备工作，包括创建会话控制器，登录表单和相关的控制器动作。然后在 <a href="#logging-in">8.2 节</a>添加所需的会话处理代码，完成登录功能。</p>
<p>和前面的章节一样，我们要在主题分支中工作，本章结束时再合并到主分支：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>git checkout master
<span class="nv">$ </span>git checkout -b log-in-log-out
</pre></div>
</div>
<section data-type="sect2" id="sessions-controller">
<h2><span class="title-label">8.1.1</span> 会话控制器</h2>
<p>登录和退出功能由会话控制器中的相应动作处理，登录表单在 <code>new</code> 动作中处理（本节的内容），登录的过程是向 <code>create</code> 动作发送 <code>POST</code> 请求（<a href="#logging-in">8.2 节</a>），退出则是向 <code>destroy</code> 动作发送 <code>DELETE</code> 请求（<a href="#logging-out">8.3 节</a>）。（HTTP 请求和 REST 动作之间的对应关系参见<a href="chapter7.html#table-restful-users">表 7.1</a>。）</p>
<p>首先，我们要生成会话控制器，以及其中的 <code>new</code> 动作：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>rails generate controller Sessions new
</pre></div>
</div>
<p>（参数中指定 <code>new</code>，其实还会生成视图，所以我们才没指定 <code>create</code> 和 <code>destroy</code>，因为这两个动作没有视图。）参照 <a href="chapter7.html#signup-form">7.2 节</a>创建注册页面的方式，我们要创建一个登录表单，用于创建会话，构思如<a href="#fig-login-mockup">图 8.1</a> 所示。</p>
<div id="fig-login-mockup" class="figure"><img src="images/chapter8/login_mockup.png" alt="login mockup" /><div class="figcaption"><span class="title-label">图 8.1</span>：登录表单的构思图</div></div>
<p>用户资源使用特殊的 <code>resources</code> 方法自动获得符合 REST 架构的路由（<a href="chapter7.html#listing-users-resource">代码清单 7.3</a>），会话资源则只能使用具名路由，处理发给 /login 地址的 <code>GET</code> 和 <code>POST</code> 请求，以及发给 /logout 地址的 <code>DELETE</code> 请求，如<a href="#listing-sessions-resource">代码清单 8.1</a> 所示。（删除了 <code>rails generate controller</code> 生成的无用路由。）</p>
<div id="listing-sessions-resource" data-type="listing">
<h5><span class="title-label">代码清单 8.1</span>：添加会话控制器的路由</h5>

<div class="source-file">config/routes.rb</div>

<div class="highlight language-ruby"><pre><span class="no">Rails</span><span class="o">.</span><span class="n">application</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">draw</span> <span class="k">do</span>
  <span class="n">root</span>                <span class="s1">'static_pages#home'</span>
  <span class="n">get</span>    <span class="s1">'help'</span>    <span class="o">=&gt;</span> <span class="s1">'static_pages#help'</span>
  <span class="n">get</span>    <span class="s1">'about'</span>   <span class="o">=&gt;</span> <span class="s1">'static_pages#about'</span>
  <span class="n">get</span>    <span class="s1">'contact'</span> <span class="o">=&gt;</span> <span class="s1">'static_pages#contact'</span>
  <span class="n">get</span>    <span class="s1">'signup'</span>  <span class="o">=&gt;</span> <span class="s1">'users#new'</span>
<span class="hll">  <span class="n">get</span>    <span class="s1">'login'</span>   <span class="o">=&gt;</span> <span class="s1">'sessions#new'</span>
</span><span class="hll">  <span class="n">post</span>   <span class="s1">'login'</span>   <span class="o">=&gt;</span> <span class="s1">'sessions#create'</span>
</span><span class="hll">  <span class="n">delete</span> <span class="s1">'logout'</span>  <span class="o">=&gt;</span> <span class="s1">'sessions#destroy'</span>
</span>  <span class="n">resources</span> <span class="ss">:users</span>
<span class="k">end</span>
</pre></div>
</div>
<p><a href="#listing-sessions-resource">代码清单 8.1</a> 中的规则会把 URL 和动作对应起来，就像<a href="chapter7.html#table-restful-users">表 7.1</a> 那样，如<a href="#table-restful-sessions">表 8.1</a> 所示。</p>
<table id="table-restful-sessions" class="tableblock frame-all grid-all" style="width: 100%;">
<caption><span class="title-label">表 8.1</span>：<a href="#listing-sessions-resource">代码清单 8.1</a> 中会话相关的规则生成的路由</caption>
<colgroup>
<col style="width: 15%;" />
<col style="width: 15%;" />
<col style="width: 15%;" />
<col style="width: 15%;" />
<col style="width: 40%;" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">HTTP 请求</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">具名路由</th>
<th class="tableblock halign-left valign-top">动作</th>
<th class="tableblock halign-left valign-top">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GET</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/login</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>login_path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>new</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建新会话的页面（登录）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POST</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/login</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>login_path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建新会话（登录）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DELETE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/logout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logout_path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destroy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除会话（退出）</p></td>
</tr>
</tbody>
</table>
<p>至此，我们添加了好几个自定义的具名路由，最好看一下路由的完整列表。我们可以执行 <code>rake routes</code> 生成路由列表：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake routes
 Prefix Verb   URI Pattern               Controller#Action
     root GET    /                         static_pages#home
     <span class="nb">help </span>GET    /help<span class="o">(</span>.:format<span class="o">)</span>           static_pages#help
    about GET    /about<span class="o">(</span>.:format<span class="o">)</span>          static_pages#about
  contact GET    /contact<span class="o">(</span>.:format<span class="o">)</span>        static_pages#contact
   signup GET    /signup<span class="o">(</span>.:format<span class="o">)</span>         users#new
    login GET    /login<span class="o">(</span>.:format<span class="o">)</span>          sessions#new
          POST   /login<span class="o">(</span>.:format<span class="o">)</span>          sessions#create
   <span class="nb">logout </span>DELETE /logout<span class="o">(</span>.:format<span class="o">)</span>         sessions#destroy
    users GET    /users<span class="o">(</span>.:format<span class="o">)</span>          users#index
          POST   /users<span class="o">(</span>.:format<span class="o">)</span>          users#create
 new_user GET    /users/new<span class="o">(</span>.:format<span class="o">)</span>      users#new
edit_user GET    /users/:id/edit<span class="o">(</span>.:format<span class="o">)</span> users#edit
     user GET    /users/:id<span class="o">(</span>.:format<span class="o">)</span>      users#show
          PATCH  /users/:id<span class="o">(</span>.:format<span class="o">)</span>      users#update
          PUT    /users/:id<span class="o">(</span>.:format<span class="o">)</span>      users#update
          DELETE /users/:id<span class="o">(</span>.:format<span class="o">)</span>      users#destroy
</pre></div>
</div>
<p>你没必要完全理解这些输出的内容。像这样查看路由能对应用支持的动作有个整体认识。</p>
</section>
<section data-type="sect2" id="login-form">
<h2><span class="title-label">8.1.2</span> 登录表单</h2>
<p>定义好相关的控制器和路由之后，我们要编写新建会话的视图，也就是登录表单。比较<a href="#fig-login-mockup">图 8.1</a> 和<a href="chapter7.html#fig-signup-mockup">图 7.11</a> 之后发现，登录表单和注册表单的外观类似，只不过登录表单只有两个输入框（电子邮件地址和密码）。</p>
<p>如<a href="#fig-login-failure-mockup">图 8.2</a> 所示，如果提交的登录信息无效，我们想重新渲染登录页面，并显示一个错误消息。在 <a href="cchapter7.html#signup-error-messages">7.3.3 节</a>，我们使用错误消息局部视图显示错误消息，但是那些消息由 Active Record 自动提供，所以错误消息局部视图不能显示创建会话时的错误，因为会话不是 Active Record 对象，因此我们要使用闪现消息渲染登录时的错误消息。</p>
<div id="fig-login-failure-mockup" class="figure"><img src="images/chapter8/login_failure_mockup.png" alt="login failure mockup" /><div class="figcaption"><span class="title-label">图 8.2</span>：登录失败后显示的页面构思图</div></div>
<p><a href="chapter7.html#listing-signup-form">代码清单 7.13</a> 中的注册表单使用 <code>form_for</code> 辅助方法，并且把表示用户实例的 <code>@user</code> 变量作为参数传给 <code>form_for</code>：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="n">form_for</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">  .</span>
<span class="x">  .</span>
<span class="x">  .</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>登录表单和注册表单之间主要的区别是，会话不是模型，因此不能创建类似 <code>@user</code> 的变量。所以，构建登录表单时，我们要为 <code>form_for</code> 稍微多提供一些信息。</p>
<p><code>form_for(@user)</code> 的作用是让表单向 /users 发起 <code>POST</code> 请求。对会话来说，我们需要指明资源的名字以及相应的 URL：<sup>[<a id="fn-ref-3" href="#fn-3">3</a>]</sup></p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="x">form_for(:session, url: login_path)</span>
</pre></div>
</div>
<p>知道怎么调用 <code>form_for</code> 之后，参照注册表单（<a href="chapter7.html#listing-signup-form">代码清单 7.13</a>）编写<a href="#fig-login-mockup">图 8.1</a> 中构思的登录表单就容易了，如<a href="#listing-login-form">代码清单 8.2</a> 所示。</p>
<div id="listing-login-form" data-type="listing">
<h5><span class="title-label">代码清单 8.2</span>：登录表单的代码</h5>

<div class="source-file">app/views/sessions/new.html.erb</div>

<div class="highlight language-erb"><pre><span class="cp">&lt;%</span> <span class="n">provide</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="s2">"Log in"</span><span class="p">)</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">&lt;h1&gt;Log in&lt;/h1&gt;</span>

<span class="x">&lt;div class="row"&gt;</span>
<span class="x">  &lt;div class="col-md-6 col-md-offset-3"&gt;</span>
<span class="x">    </span><span class="cp">&lt;%=</span> <span class="n">form_for</span><span class="p">(</span><span class="ss">:session</span><span class="p">,</span> <span class="ss">url</span><span class="p">:</span> <span class="n">login_path</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="cp">%&gt;</span><span class="x"></span>

<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">label</span> <span class="ss">:email</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">email_field</span> <span class="ss">:email</span> <span class="cp">%&gt;</span><span class="x"></span>

<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">label</span> <span class="ss">:password</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">password_field</span> <span class="ss">:password</span> <span class="cp">%&gt;</span><span class="x"></span>

<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">submit</span> <span class="s2">"Log in"</span><span class="p">,</span> <span class="ss">class</span><span class="p">:</span> <span class="s2">"btn btn-primary"</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">    </span><span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>

<span class="x">    &lt;p&gt;New user? </span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Sign up now!"</span><span class="p">,</span> <span class="n">signup_path</span> <span class="cp">%&gt;</span><span class="x">&lt;/p&gt;</span>
<span class="x">  &lt;/div&gt;</span>
<span class="x">&lt;/div&gt;</span>
</pre></div>
</div>
<p>注意，为了操作方便，我们还加入了到“注册”页面的链接。<a href="#listing-login-form">代码清单 8.2</a> 中的登录表单如<a href="#fig-login-form">图 8.3</a> 所示。（导航条中的“Log in”还没填写地址，所以你要在地址栏中输入 /login。<a href="#changing-the-layout-links">8.2.3 节</a>会修正这个问题。）</p>
<div id="fig-login-form" class="figure"><img src="images/chapter8/login_form.png" alt="login form" /><div class="figcaption"><span class="title-label">图 8.3</span>：登录表单</div></div>
<p>生成的表单 HTML 如<a href="#listing-login-form-html">代码清单 8.3</a> 所示。</p>
<div id="listing-login-form-html" data-type="listing">
<h5><span class="title-label">代码清单 8.3</span>：<a href="#listing-login-form">代码清单 8.2</a> 中登录表单生成的 HTML</h5>


<div class="highlight language-html"><pre><span class="nt">&lt;form</span> <span class="na">accept-charset=</span><span class="s">"UTF-8"</span> <span class="na">action=</span><span class="s">"/login"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">name=</span><span class="s">"utf8"</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">value=</span><span class="s">"&amp;#x2713;"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">name=</span><span class="s">"authenticity_token"</span> <span class="na">type=</span><span class="s">"hidden"</span>
         <span class="na">value=</span><span class="s">"NNb6+J/j46LcrgYUC60wQ2titMuJQ5lLqyAbnbAUkdo="</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;label</span> <span class="na">for=</span><span class="s">"session_email"</span><span class="nt">&gt;</span>Email<span class="nt">&lt;/label&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">id=</span><span class="s">"session_email"</span> <span class="na">name=</span><span class="s">"session[email]"</span> <span class="na">type=</span><span class="s">"text"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;label</span> <span class="na">for=</span><span class="s">"session_password"</span><span class="nt">&gt;</span>Password<span class="nt">&lt;/label&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">id=</span><span class="s">"session_password"</span> <span class="na">name=</span><span class="s">"session[password]"</span>
         <span class="na">type=</span><span class="s">"password"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">class=</span><span class="s">"btn btn-primary"</span> <span class="na">name=</span><span class="s">"commit"</span> <span class="na">type=</span><span class="s">"submit"</span>
       <span class="na">value=</span><span class="s">"Log in"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>
</div>
<p>对比一下<a href="#listing-login-form-html">代码清单 8.3</a> 和<a href="chapter7.html#listing-signup-form-html">代码清单 7.15</a>，你可能已经猜到了，提交登录表单后会生成一个 <code>params</code> 哈希，其中 <code>params[:session][:email]</code> 和 <code>params[:session][:password]</code> 分别对应电子邮件地址和密码字段。</p>
</section>
<section data-type="sect2" id="finding-and-authenticating-a-user">
<h2><span class="title-label">8.1.3</span> 查找并认证用户</h2>
<p>和创建用户类似，创建会话（登录）时先要处理提交无效数据的情况。我们会先分析提交表单后会发生什么，想办法在登录失败时显示有帮助的错误消息（如<a href="#fig-login-failure-mockup">图 8.2</a> 中的构思）。然后，以此为基础，验证提交的电子邮件地址和密码，处理登录成功的情况（<a href="#logging-in">8.2 节</a>）。</p>
<p>首先，我们要为会话控制器编写一个最简单的 <code>create</code> 动作，以及空的 <code>new</code> 动作和 <code>destroy</code> 动作，如<a href="#listing-initial-create-session">代码清单 8.4</a> 所示。<code>create</code> 动作现在只渲染 <code>new</code> 视图，不过为后续工作做好了准备。提交 /login 页面中的表单后，显示的页面如<a href="#fig-initial-failed-login-rails-3">图 8.4</a> 所示。</p>
<div id="listing-initial-create-session" data-type="listing">
<h5><span class="title-label">代码清单 8.4</span>：会话控制器中 <code>create</code> 动作的初始版本</h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
<span class="hll">    <span class="n">render</span> <span class="s1">'new'</span>
</span>  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<div id="fig-initial-failed-login-rails-3" class="figure"><img src="images/chapter8/initial_failed_login_3rd_edition.png" alt="initial failed login 3rd edition" /><div class="figcaption"><span class="title-label">图 8.4</span>：添加<a href="#listing-initial-create-session">代码清单 8.4</a> 中的 <code>create</code> 动作后，登录失败后显示的页面</div></div>
<p>仔细看一下<a href="#fig-initial-failed-login-rails-3">图 8.4</a> 中显示的调试信息，你会发现，正如 <a href="#login-form">8.1.2 节</a>末尾所说的，提交表单后会生成 <code>params</code> 哈希，电子邮件地址和密码都在 <code>:session</code> 键中（下述代码省略了一些 Rails 内部使用的信息）：</p>
<div data-type="listing">


<div class="highlight language-yaml"><pre><span class="nn">---</span>
<span class="l-Scalar-Plain">session</span><span class="p-Indicator">:</span>
  <span class="l-Scalar-Plain">email</span><span class="p-Indicator">:</span> <span class="s">'user@example.com'</span>
  <span class="l-Scalar-Plain">password</span><span class="p-Indicator">:</span> <span class="s">'foobar'</span>
<span class="l-Scalar-Plain">commit</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Log in</span>
<span class="l-Scalar-Plain">action</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">create</span>
<span class="l-Scalar-Plain">controller</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">sessions</span>
</pre></div>
</div>
<p>和注册表单类似（<a href="chapter7.html#fig-signup-failure">图 7.15</a>），这些参数是一个嵌套哈希，在<a href="chapter4.html#listing-nested-hashes">代码清单 4.10</a> 中见过。具体而言，<code>params</code> 包含了如下的嵌套哈希：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="p">{</span> <span class="ss">session</span><span class="p">:</span> <span class="p">{</span> <span class="ss">password</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span> <span class="p">}</span> <span class="p">}</span>
</pre></div>
</div>
<p>也就是说</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">]</span>
</pre></div>
</div>
<p>本身就是一个哈希：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="p">{</span> <span class="ss">password</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span> <span class="p">}</span>
</pre></div>
</div>
<p>所以，</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">]</span>
</pre></div>
</div>
<p>是提交的电子邮件地址，而</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span>
</pre></div>
</div>
<p>是提交的密码。</p>
<p>也就是说，在 <code>create</code> 动作中，<code>params</code> 哈希包含了使用电子邮件地址和密码认证用户身份所需的全部数据。其实，我们已经有了需要使用的方法：Active Record 提供的 <code>User.find_by</code> 方法（<a href="chapter6.html#finding-user-objects">6.1.4 节</a>）和 <code>has_secure_password</code> 提供的 <code>authenticate</code> 方法（<a href="chapter6.html#creating-and-authenticating-a-user">6.3.4 节</a>）。前面说过，如果认证失败，<code>authenticate</code> 方法会返回 <code>false</code>。基于以上分析，我们计划按照<a href="#listing-find-authenticate-user">代码清单 8.5</a> 中的方式实现用户登录功能。</p>
<div id="listing-find-authenticate-user" data-type="listing">
<h5><span class="title-label">代码清单 8.5</span>：查找并认证用户</h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
<span class="hll">    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">].</span><span class="n">downcase</span><span class="p">)</span>
</span><span class="hll">    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
</span>      <span class="c1"># 登入用户，然后重定向到用户的资料页面</span>
    <span class="k">else</span>
      <span class="c1"># 创建一个错误消息</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p><a href="#listing-find-authenticate-user">代码清单 8.5</a> 中高亮显示的第一行使用提交的电子邮件地址从数据库中取出相应的用户。（我们在 <a href="chapter6.html#uniqueness-validation">6.2.5 节</a>说过，电子邮件地址都是以小写字母形式保存的，所以这里调用了 <code>downcase</code> 方法，确保提交有效的地址后能查到相应的记录。）高亮显示的第二行看起来很怪，但在 Rails 中经常使用：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p>我们使用 <code>&amp;&amp;</code>（逻辑与）检测获取的用户是否有效。因为除了 <code>nil</code> 和 <code>false</code> 之外的所有对象都被视作 <code>true</code>，上面这个语句可能出现的结果如<a href="#table-user-and-and">表 8.2</a>所示。从表中可以看出，当且仅当数据库中存在提交的电子邮件地址，而且对应的密码和提交的密码匹配时，这个语句才会返回 <code>true</code>。</p>
<table id="table-user-and-and" class="tableblock frame-all grid-all" style="width: 100%;">
<caption><span class="title-label">表 8.2</span>：<code>user &amp;&amp; user.authenticate(…​)</code> 可能得到的结果</caption>
<colgroup>
<col style="width: 33%;" />
<col style="width: 33%;" />
<col style="width: 33%;" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">用户</th>
<th class="tableblock halign-left valign-top">密码</th>
<th class="tableblock halign-left valign-top">a &amp;&amp; b</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">不存在</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(nil &amp;&amp; [anything]) == false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">存在</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误的密码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(true &amp;&amp; false) == false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">存在</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正确的密码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(true &amp;&amp; true) == true</code></p></td>
</tr>
</tbody>
</table>
</section>
<section data-type="sect2" id="rendering-with-a-flash-message">
<h2><span class="title-label">8.1.4</span> 渲染闪现消息</h2>
<p>在 <a href="chapter7.html#signup-error-messages">7.3.3 节</a>，我们使用用户模型的验证错误显示注册失败时的错误消息。这些错误关联在某个 Active Record 对象上，不过现在不能使用这种方式了，因为会话不是 Active Record 模型。我们要采取的方法是，登录失败时，在闪现消息中显示消息。<a href="#listing-failed-login-attempt">代码清单 8.6</a> 是我们首次尝试实现所写的代码，其中有个小小的错误。</p>
<div id="listing-failed-login-attempt" data-type="listing">
<h5><span class="title-label">代码清单 8.6</span>：尝试处理登录失败（有个小小的错误）</h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">].</span><span class="n">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
      <span class="c1"># 登入用户，然后重定向到用户的资料页面</span>
    <span class="k">else</span>
<span class="hll">      <span class="n">flash</span><span class="o">[</span><span class="ss">:danger</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span> <span class="c1"># 不完全正确</span>
</span>      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>布局中已经加入了显示闪现消息的局部视图（<a href="chapter7.html#listing-layout-flash">代码清单 7.25</a>），所以无需其他修改，<code>flash[:danger]</code> 消息就会显示出来，而且因为使用了 Bootstrap 提供的 CSS，消息的样式也很美观，如<a href="#fig-failed-login-flash">图 8.5</a> 所示。</p>
<p>不过，就像<a href="#listing-failed-login-attempt">代码清单 8.6</a> 中的注释所说，代码不完全正确。显示的页面看起来很正常啊，有什么问题呢？问题在于，闪现消息在一个请求的生命周期内是持续存在的，而重新渲染页面（使用 <code>render</code> 方法）和<a href="chapter7.html#listing-signup-flash">代码清单 7.24</a> 中的重定向不同，不算是一次新请求，所以你会发现这个闪现消息存在的时间比预计的要长很多。例如，提交无效的登录信息，然后访问首页，还会显示这个闪现消息，如<a href="#fig-flash-persistence">图 8.6</a> 所示。<a href="#a-flash-test">8.1.5 节</a>会修正这个问题。</p>
<div id="fig-failed-login-flash" class="figure"><img src="images/chapter8/failed_login_flash_3rd_edition.png" alt="failed login flash 3rd edition" /><div class="figcaption"><span class="title-label">图 8.5</span>：登录失败后显示的闪现消息</div></div>
<div id="fig-flash-persistence" class="figure"><img src="images/chapter8/flash_persistence_3rd_edition.png" alt="flash persistence 3rd edition" /><div class="figcaption"><span class="title-label">图 8.6</span>：闪现消息一直存在</div></div>
</section>
<section data-type="sect2" id="a-flash-test">
<h2><span class="title-label">8.1.5</span> 测试闪现消息</h2>
<p>闪现消息的错误表现是应用的一个小 bug。根据<a href="chapter3.html#aside-when-to-test">旁注 3.3</a> 中的测试指导方针，遇到这种情况应该编写测试，捕获错误，防止以后再发生。因此，在继续之前，我们要为登录表单的提交操作编写一个简短的集成测试。测试能标识出这个问题，也能避免回归，而且还能为后面的登录和退出功能的集成测试奠定好的基础。</p>
<p>首先，为应用的登录功能生成一个集成测试文件：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="hll"><span class="nv">$ </span>rails generate integration_test users_login
</span>      invoke  test_unit
      create    <span class="nb">test</span>/integration/users_login_test.rb
</pre></div>
</div>
<p>然后，我们要编写一个测试，模拟<a href="#fig-failed-login-flash">图 8.5</a> 和<a href="#fig-flash-persistence">图 8.6</a> 中的连续操作。基本的步骤如下所示：</p>
<ol class="arabic">
<li>
<p>访问登录页面；</p>
</li>
<li>
<p>确认正确渲染了登录表单；</p>
</li>
<li>
<p>提交无效的 <code>params</code> 哈希，向登录页面发起 <code>post</code> 请求；</p>
</li>
<li>
<p>确认重新渲染了登录表单，而且显示了一个闪现消息；</p>
</li>
<li>
<p>访问其他页面（例如首页）；</p>
</li>
<li>
<p>确认这个页面中没显示前面那个闪现消息。</p>
</li>
</ol>
<p>实现上述步骤的测试如<a href="#listing-flash-persistence-test">代码清单 8.7</a> 所示。</p>
<div id="listing-flash-persistence-test" data-type="listing">
<h5><span class="title-label">代码清单 8.7</span>：捕获继续显示闪现消息的测试 <span class="red">RED</span></h5>

<div class="source-file">test/integration/users_login_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">UsersLoginTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>

  <span class="nb">test</span> <span class="s2">"login with invalid information"</span> <span class="k">do</span>
    <span class="n">get</span> <span class="n">login_path</span>
    <span class="n">assert_template</span> <span class="s1">'sessions/new'</span>
    <span class="n">post</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">session</span><span class="p">:</span> <span class="p">{</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span> <span class="ss">password</span><span class="p">:</span> <span class="s2">""</span> <span class="p">}</span>
    <span class="n">assert_template</span> <span class="s1">'sessions/new'</span>
    <span class="n">assert_not</span> <span class="n">flash</span><span class="o">.</span><span class="n">empty?</span>
    <span class="n">get</span> <span class="n">root_path</span>
    <span class="n">assert</span> <span class="n">flash</span><span class="o">.</span><span class="n">empty?</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>添加上述测试之后，登录测试应该失败：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.8</span>：<strong class="red">RED</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test </span><span class="nv">TEST</span><span class="o">=</span><span class="nb">test</span>/integration/users_login_test.rb
</pre></div>
</div>
<p>上述命令指定 <code>TEST</code> 参数和文件的完整路径，演示如何只运行一个测试文件。</p>
<p>让<a href="#listing-flash-persistence-test">代码清单 8.7</a> 中的测试通过的方法是，把 <code>flash</code> 换成特殊的 <code>flash.now</code>。<code>flash.now</code> 专门用于在重新渲染的页面中显示闪现消息。和 <code>flash</code> 不同的是，<code>flash.now</code> 中的内容会在下次请求时消失——这正是<a href="#listing-flash-persistence-test">代码清单 8.7</a> 中的测试所需的表现。替换之后，正确的应用代码如<a href="#listing-correct-login-failure">代码清单 8.9</a> 所示。</p>
<div id="listing-correct-login-failure" data-type="listing">
<h5><span class="title-label">代码清单 8.9</span>：处理登录失败正确的代码 <span class="green">GREEN</span></h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">].</span><span class="n">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
      <span class="c1"># 登入用户，然后重定向到用户的资料页面</span>
    <span class="k">else</span>
<span class="hll">      <span class="n">flash</span><span class="o">.</span><span class="n">now</span><span class="o">[</span><span class="ss">:danger</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span>
</span>      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>然后，我们可以确认登录功能的集成测试和整个测试组件都能通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.10</span>：<strong class="green">GREEN</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test </span><span class="nv">TEST</span><span class="o">=</span><span class="nb">test</span>/integration/users_login_test.rb
<span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
</section>
</section>
<section data-type="sect1" id="logging-in">
<h1><span class="title-label">8.2</span> 登录</h1>
<p>登录表单已经可以处理无效提交，下一步要正确处理有效提交，登入用户。本节通过临时会话让用户登录，浏览器关闭后会话自动失效。<a href="#remember-me">8.4 节</a>会实现持久会话，即便浏览器关闭，依然处于登录状态。</p>
<p>实现会话的过程中要定义很多相关的函数，而且要在多个控制器和视图中使用。<a href="chapter4.html#back-to-the-title-helper">4.2.5 节</a>说过，Ruby 支持使用“模块”把这些函数集中放在一处。Rails 生成器很人性化，生成会话控制器时（<a href="#sessions-controller">8.1.1 节</a>）自动生成了一个会话辅助方法模块。而且，其中的辅助方法会自动引入 Rails 视图。如果在控制器的基类（<code>ApplicationController</code>）中引入辅助方法模块，还可以在控制器中使用，如<a href="#listing-sessions-helper-include">代码清单 8.11</a> 所示。</p>
<div id="listing-sessions-helper-include" data-type="listing">
<h5><span class="title-label">代码清单 8.11</span>：在 <code>ApplicationController</code> 中引入会话辅助方法模块</h5>

<div class="source-file">app/controllers/application_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">protect_from_forgery</span> <span class="ss">with</span><span class="p">:</span> <span class="ss">:exception</span>
<span class="hll">  <span class="kp">include</span> <span class="no">SessionsHelper</span>
</span><span class="k">end</span>
</pre></div>
</div>
<p>做好这些基础工作后，现在可以开始编写代码登入用户了。</p>
<section data-type="sect2" id="the-log-in-method">
<h2><span class="title-label">8.2.1</span> <code>log_in</code> 方法</h2>
<p>有 Rails 提供的 <code>session</code> 方法协助，登入用户很简单。（<code>session</code> 方法和 <a href="#sessions-controller">8.1.1 节</a>生成的会话控制器没有关系。）我们可以把 <code>session</code> 视作一个哈希，可以按照下面的方式赋值：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p>这么做会在用户的浏览器中创建一个临时 cookie，内容是加密后的用户 ID。在后续的请求中，可以使用 <code>session[:user_id]</code> 取回这个 ID。<a href="#remember-me">8.4 节</a>使用的 <code>cookies</code> 方法创建的是持久 cookie，而 <code>session</code> 方法创建的是临时会话，浏览器关闭后立即失效。</p>
<p>我们想在多个不同的地方使用这个登录方式，所以在会话辅助方法模块中定义一个名为 <code>log_in</code> 的方法，如<a href="#listing-log-in-function">代码清单 8.12</a> 所示。</p>
<div id="listing-log-in-function" data-type="listing">
<h5><span class="title-label">代码清单 8.12</span>：<code>log_in</code> 方法</h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="c1"># 登入指定的用户</span>
  <span class="k">def</span> <span class="nf">log_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="hll">    <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p><code>session</code> 方法创建的临时 cookie 会自动加密，所以<a href="#listing-log-in-function">代码清单 8.12</a> 中的代码是安全的，攻击者无法使用会话中的信息以该用户的身份登录。不过，只有 <code>session</code> 方法创建的临时 cookie 是这样，<code>cookies</code> 方法创建的持久 cookie 则有可能会受到“会话劫持”（session hijacking）攻击。所以在 <a href="#remember-me">8.4 节</a>我们会小心处理存入用户浏览器中的信息。</p>
<p>定义好 <code>log_in</code> 方法后，我们可以完成会话控制器中的 <code>create</code> 动作了——登入用户，然后重定向到用户的资料页面，如<a href="#listing-log-in-success">代码清单 8.13</a> 所示。<sup>[<a id="fn-ref-4" href="#fn-4">4</a>]</sup></p>
<div id="listing-log-in-success" data-type="listing">
<h5><span class="title-label">代码清单 8.13</span>：登入用户</h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">].</span><span class="n">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
<span class="hll">      <span class="n">log_in</span> <span class="n">user</span>
</span><span class="hll">      <span class="n">redirect_to</span> <span class="n">user</span>
</span>    <span class="k">else</span>
      <span class="n">flash</span><span class="o">.</span><span class="n">now</span><span class="o">[</span><span class="ss">:danger</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>注意简洁的重定向代码</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">redirect_to</span> <span class="n">user</span>
</pre></div>
</div>
<p>我们在 <a href="chapter7.html#the-finished-signup-form">7.4.1 节</a>见过。Rails 会自动把地址转换成用户资料页的地址：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">user_url</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</pre></div>
</div>
<p>定义好 <code>create</code> 动作后，<a href="#listing-login-form">代码清单 8.2</a> 中的登录表单就可以使用了。不过从应用的外观上看不出什么区别，除非直接查看浏览器中的会话，否则没有方法判断用户是否已经登录。<a href="#current-user">8.2.2 节</a>会使用会话中的用户 ID 从数据库中取回当前用户，做些视觉上的变化。<a href="#changing-the-layout-links">8.2.3 节</a>会修改网站布局中的链接，还会添加一个指向当前用户资料页面的链接。</p>
</section>
<section data-type="sect2" id="current-user">
<h2><span class="title-label">8.2.2</span> 当前用户</h2>
<p>把用户 ID 安全地存储在临时会话中之后，在后续的请求中可以将其读取出来。我们要定义一个名为 <code>current_user</code> 的方法，从数据库中取出用户 ID 对应的用户。<code>current_user</code> 方法的作用是编写类似下面的代码：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="n">current_user</span><span class="o">.</span><span class="n">name</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>或是：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">redirect_to</span> <span class="n">current_user</span>
</pre></div>
</div>
<p>查找用户的方法之一是使用 <code>find</code> 方法，在用户资料页面就是这么做的（<a href="chapter7.html#listing-user-show-action">代码清单 7.5</a>）：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p><a href="chapter6.html#finding-user-objects">6.1.4 节</a>说过，如果用户 ID 不存在，<code>find</code> 方法会抛出异常。在用户的资料页面可以使用这种表现，因为必须有相应的用户才能显示他的信息。但 <code>session[:user_id]</code> 的值经常是 <code>nil</code>（表示用户未登录），所以我们要使用 <code>create</code> 动作中通过电子邮件地址查找用户的 <code>find_by</code> 方法，通过 <code>id</code> 查找用户：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 ID 无效，<code>find_by</code> 方法返回 <code>nil</code>，而不会抛出异常。</p>
<p>因此，我们可以按照下面的方式定义 <code>current_user</code> 方法：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">def</span> <span class="nf">current_user</span>
  <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>这样定义应该可以，不过如果页面中多次调用 <code>current_user</code>，就会多次查询数据库。所以，我们要使用一种 Ruby 习惯写法，把 <code>User.find_by</code> 的结果存储在实例变量中，只在第一次调用时查询数据库，后续再调用直接返回实例变量中存储的值：<sup>[<a id="fn-ref-5" href="#fn-5">5</a>]</sup></p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="vi">@current_user</span><span class="o">.</span><span class="n">nil?</span>
  <span class="vi">@current_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
<span class="k">else</span>
  <span class="vi">@current_user</span>
<span class="k">end</span>
</pre></div>
</div>
<p>使用 <a href="chapter4.html#objects-and-message-passing">4.2.3 节</a>中介绍的“或”操作符 <code>||</code>，可以把这段代码改写成：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="vi">@current_user</span> <span class="o">=</span> <span class="vi">@current_user</span> <span class="o">||</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p><code>User</code> 对象是真值，所以仅当 <code>@current_user</code> 没有赋值时才会执行 <code>find_by</code> 方法。</p>
<p>上述代码虽然可以使用，但并不符合 Ruby 的习惯。<code>@current_user</code> 赋值语句的正确写法是这样：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p>这种写法用到了容易让人困惑的 <code>||=</code>（或等）操作符，参见<a href="#aside-or-equals">旁注 8.1</a> 中的说明。</p>
<div data-type="sidebar" id="aside-or-equals" class="sidebar">
<h5><span class="title-label">旁注 8.1</span>：<code>||=</code> 操作符简介</h5>
<p><code>||=</code>（或等）赋值操作符在 Ruby 中常用，因此有追求的 Rails 开发者要学会使用。初学时可能会觉得 <code>||=</code> 很神秘，不过和其他操作符对比之后，你会发现也不难理解。</p>
<p>我们先来看一下常见的变量自增一赋值：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>很多编程语言都为这种操作提供了简化的操作符，在 Ruby 中（C、C++、Perl、Python、Java 等也可以），可以写成下面这样：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>其他操作符也有类似的简化形式：</p>
<div data-type="listing">


<div class="highlight language-irb"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="go">=&gt; 1</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="go">=&gt; 2</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">*=</span> <span class="mi">3</span>
<span class="go">=&gt; 6</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">-=</span> <span class="mi">8</span>
<span class="go">=&gt; -2</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">/=</span> <span class="mi">2</span>
<span class="go">=&gt; -1</span>
</pre></div>
</div>
<p>通过上面的例子可以得知，<code>x = x O y</code> 和 <code>x O=y</code> 是等效的，其中 <code>O</code> 表示操作符。</p>
<p>在 Ruby 中还经常会遇到这种情况，如果变量的值为 <code>nil</code> 则给它赋值，否则就不改变这个变量的值。我们可以使用 <a href="chapter4.html#objects-and-message-passing">4.2.3 节</a>介绍的或操作符（<code>||</code>）编写下面的代码：</p>
<div data-type="listing">


<div class="highlight language-irb"><pre><span class="gp">&gt;&gt; </span><span class="vi">@foo</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="vi">@foo</span> <span class="o">=</span> <span class="vi">@foo</span> <span class="o">||</span> <span class="s2">"bar"</span>
<span class="go">=&gt; "bar"</span>
<span class="gp">&gt;&gt; </span><span class="vi">@foo</span> <span class="o">=</span> <span class="vi">@foo</span> <span class="o">||</span> <span class="s2">"baz"</span>
<span class="go">=&gt; "bar"</span>
</pre></div>
</div>
<p>因为 <code>nil</code> 是“假值”，所以第一个赋值语句等同于 <code>nil || "bar"</code>，得到的结果是 <code>"bar"</code>。同样，第二个赋值操作等同于 <code>"bar" || "baz"</code>，得到的结果还是 <code>"bar"</code>。这是因为除了 <code>nil</code> 和 <code>false</code> 之外，其他值都是“真值”，而如果第一个表达式的值是真值，<code>||</code> 会终止执行。（或操作的执行顺序从左至右，只要出现真值就会终止语句的执行，这种方式叫“短路计算”（short-circuit evaluation）。）</p>
<p>和前面的控制台会话对比之后，我们发现 <code>@foo = @foo || "bar"</code> 符合 <code>x = x O y</code> 形式，其中 <code>||</code> 就是 <code>O</code>：</p>
<div data-type="listing">


<div class="highlight language-text"><pre>x    =   x   +   1      -&gt;     x     +=   1
x    =   x   *   3      -&gt;     x     *=   3
x    =   x   -   8      -&gt;     x     -=   8
x    =   x   /   2      -&gt;     x     /=   2
@foo = @foo || "bar"    -&gt;     @foo ||= "bar"
</pre></div>
</div>
<p>因此，<code>@foo = @foo || "bar"</code> 和 <code>@foo ||= "bar"</code> 两种写法是等效的。在获取当前用户时，建议使用下面的写法：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p>不难理解吧！<sup>[<a id="fn-ref-6" href="#fn-6">6</a>]</sup></p>
</div>
<p>综上所述，<code>current_user</code> 方法更简洁的定义方式如<a href="#listing-current-user">代码清单 8.14</a> 所示。</p>
<div id="listing-current-user" data-type="listing">
<h5><span class="title-label">代码清单 8.14</span>：在会话中查找当前用户</h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="c1"># 登入指定的用户</span>
  <span class="k">def</span> <span class="nf">log_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
  <span class="k">end</span>

  <span class="c1"># 返回当前登录的用户（如果有的话）</span>
  <span class="k">def</span> <span class="nf">current_user</span>
<span class="hll">    <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>定义好 <code>current_user</code> 之后，现在可以根据用户的登录状态修改应用的布局了。</p>
</section>
<section data-type="sect2" id="changing-the-layout-links">
<h2><span class="title-label">8.2.3</span> 修改布局中的链接</h2>
<p>实现登录功能后，我们要根据登录状态修改布局中的链接。具体而言，我们要添加退出链接、用户设置页面的链接、用户列表页面的链接和当前用户的资料页面链接，构思图如<a href="#fig-login-success-mockup">图 8.7</a> 所示。<sup>[<a id="fn-ref-7" href="#fn-7">7</a>]</sup>注意，退出链接和资料页面的链接在“Account”（账户）下拉菜单中。使用 Bootstrap 实现下拉菜单的方法参见<a href="#listing-layout-login-logout-links">代码清单 8.16</a>。</p>
<div id="fig-login-success-mockup" class="figure"><img src="images/chapter8/login_success_mockup.png" alt="login success mockup" /><div class="figcaption"><span class="title-label">图 8.7</span>：成功登录后显示的资料页面构思图</div></div>
<p>此时，在现实开发中，我会考虑编写集成测试检测上面规划的行为。我在<a href="chapter3.html#aside-when-to-test">旁注 3.3</a> 中说过，当你熟练掌握 Rails 的测试工具后，会倾向于先写测试。但这个测试涉及到一些新知识，所以最好在专门的一节中编写（<a href="#testing-layout-changes">8.2.4 节</a>）。</p>
<p>修改网站布局中的链接时要在 ERb 中使用 <code>if-else</code> 语句，用户登录时显示一组链接，未登录时显示另一组链接：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%</span> <span class="k">if</span> <span class="n">logged_in?</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">  # 登录用户看到的链接</span>
<span class="cp">&lt;%</span> <span class="k">else</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">  # 未登录用户看到的链接</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>为了编写这种代码，我们需要定义 <code>logged_in?</code> 方法，返回布尔值。</p>
<p>用户登录后，当前用户存储在会话中，即 <code>current_user</code> 不是 <code>nil</code>。检测会话中有没有当前用户要使用“非”操作符（<a href="chapter4.html#objects-and-message-passing">4.2.3 节</a>）。“非”操作符写做 <code>!</code>，经常读作“bang”。<code>logged_in?</code> 方法的定义如<a href="#listing-logged-in-p">代码清单 8.15</a> 所示。</p>
<div id="listing-logged-in-p" data-type="listing">
<h5><span class="title-label">代码清单 8.15</span>：<code>logged_in?</code> 辅助方法</h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="c1"># 登入指定的用户</span>
  <span class="k">def</span> <span class="nf">log_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
  <span class="k">end</span>

  <span class="c1"># 返回当前登录的用户（如果有的话）</span>
  <span class="k">def</span> <span class="nf">current_user</span>
    <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># 如果用户已登录，返回 true，否则返回 false</span>
  <span class="k">def</span> <span class="nf">logged_in?</span>
<span class="hll">    <span class="o">!</span><span class="n">current_user</span><span class="o">.</span><span class="n">nil?</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>定义好 <code>logged_in?</code> 方法之后，可以修改用户登录后显示的链接了。我们要添加四个新链接，其中两个链接的地址先使用占位符，<a href="chapter9.html#updating-showing-and-deleting-users">第 9 章</a>会换成真正的地址：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Users"</span><span class="p">,</span>    <span class="s1">'#'</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Settings"</span><span class="p">,</span> <span class="s1">'#'</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>退出链接使用<a href="#listing-sessions-resource">代码清单 8.1</a> 中定义的退出页面地址：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Log out"</span><span class="p">,</span> <span class="n">logout_path</span><span class="p">,</span> <span class="nb">method</span><span class="p">:</span> <span class="s2">"delete"</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>注意，退出链接中指定了哈希参数，指明这个链接发送的是 HTTP <code>DELETE</code> 请求。<sup>[<a id="fn-ref-8" href="#fn-8">8</a>]</sup>我们还要添加资料页面的链接：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Profile"</span><span class="p">,</span> <span class="n">current_user</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>这个链接可以写成：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Profile"</span><span class="p">,</span> <span class="n">user_path</span><span class="p">(</span><span class="n">current_user</span><span class="p">)</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>和之前一样，我们可以直接链接到用户对象，Rails 会自动把 <code>current_user</code> 转换成 <code>user_path(current_user)</code>。最后，如果用户未登录，我们要添加一个链接，使用<a href="#listing-sessions-resource">代码清单 8.1</a> 中定义的登录地址，链接到登录页面：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Log in"</span><span class="p">,</span> <span class="n">login_path</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>把这些链接都放到头部局部视图中，得到的视图如<a href="#listing-layout-login-logout-links">代码清单 8.16</a> 所示。</p>
<div id="listing-layout-login-logout-links" data-type="listing">
<h5><span class="title-label">代码清单 8.16</span>：修改布局中的链接</h5>

<div class="source-file">app/views/layouts/_header.html.erb</div>

<div class="highlight language-erb"><pre><span class="x">&lt;header class="navbar navbar-fixed-top navbar-inverse"&gt;</span>
<span class="x">  &lt;div class="container"&gt;</span>
<span class="x">    </span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"sample app"</span><span class="p">,</span> <span class="n">root_path</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="s2">"logo"</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">    &lt;nav&gt;</span>
<span class="x">      &lt;ul class="nav navbar-nav navbar-right"&gt;</span>
<span class="x">        &lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Home"</span><span class="p">,</span> <span class="n">root_path</span> <span class="cp">%&gt;</span><span class="x">&lt;/li&gt;</span>
<span class="x">        &lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Help"</span><span class="p">,</span> <span class="n">help_path</span> <span class="cp">%&gt;</span><span class="x">&lt;/li&gt;</span>
<span class="hll"><span class="x">        </span><span class="cp">&lt;%</span> <span class="k">if</span> <span class="n">logged_in?</span> <span class="cp">%&gt;</span><span class="x"></span>
</span><span class="hll"><span class="x">          &lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Users"</span><span class="p">,</span> <span class="s1">'#'</span> <span class="cp">%&gt;</span><span class="x">&lt;/li&gt;</span>
</span><span class="x">          &lt;li class="dropdown"&gt;</span>
<span class="x">            &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;</span>
<span class="x">              Account &lt;b class="caret"&gt;&lt;/b&gt;</span>
<span class="x">            &lt;/a&gt;</span>
<span class="x">            &lt;ul class="dropdown-menu"&gt;</span>
<span class="hll"><span class="x">              &lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Profile"</span><span class="p">,</span> <span class="n">current_user</span> <span class="cp">%&gt;</span><span class="x">&lt;/li&gt;</span>
</span><span class="hll"><span class="x">              &lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Settings"</span><span class="p">,</span> <span class="s1">'#'</span> <span class="cp">%&gt;</span><span class="x">&lt;/li&gt;</span>
</span><span class="x">              &lt;li class="divider"&gt;&lt;/li&gt;</span>
<span class="x">              &lt;li&gt;</span>
<span class="hll"><span class="x">                </span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Log out"</span><span class="p">,</span> <span class="n">logout_path</span><span class="p">,</span> <span class="nb">method</span><span class="p">:</span> <span class="s2">"delete"</span> <span class="cp">%&gt;</span><span class="x"></span>
</span><span class="x">              &lt;/li&gt;</span>
<span class="x">            &lt;/ul&gt;</span>
<span class="x">          &lt;/li&gt;</span>
<span class="hll"><span class="x">        </span><span class="cp">&lt;%</span> <span class="k">else</span> <span class="cp">%&gt;</span><span class="x"></span>
</span><span class="hll"><span class="x">          &lt;li&gt;</span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Log in"</span><span class="p">,</span> <span class="n">login_path</span> <span class="cp">%&gt;</span><span class="x">&lt;/li&gt;</span>
</span><span class="hll"><span class="x">        </span><span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
</span><span class="x">      &lt;/ul&gt;</span>
<span class="x">    &lt;/nav&gt;</span>
<span class="x">  &lt;/div&gt;</span>
<span class="x">&lt;/header&gt;</span>
</pre></div>
</div>
<p>除了在布局中添加新链接之外，<a href="#listing-layout-login-logout-links">代码清单 8.16</a> 还借助 Bootstrap 实现了下拉菜单。<sup>[<a id="fn-ref-9" href="#fn-9">9</a>]</sup>注意这段代码中使用的几个 Bootstrap CSS 类：<code>dropdown</code>，<code>dropdown-menu</code> 等。为了让下拉菜单生效，我们要在 <code>application.js</code>（Asset Pipeline 的一部分）中引入 Bootstrap 提供的 JavaScript 库，如<a href="#listing-bootstrap-js">代码清单 8.17</a> 所示。</p>
<div id="listing-bootstrap-js" data-type="listing">
<h5><span class="title-label">代码清单 8.17</span>：在 <code>application.js</code> 中引入 Bootstrap JavaScript 库</h5>

<div class="source-file">app/assets/javascripts/application.js</div>

<div class="highlight language-javascript"><pre><span class="c1">//= require jquery</span>
<span class="c1">//= require jquery_ujs</span>
<span class="hll"><span class="c1">//= require bootstrap</span>
</span><span class="c1">//= require turbolinks</span>
<span class="c1">//= require_tree .</span>
</pre></div>
</div>
<p>现在，你应该访问登录页面，然后使用有效账户登录——这样足以测试前三节编写的代码表现是否正常。<sup>[<a id="fn-ref-10" href="#fn-10">10</a>]</sup>添加<a href="#listing-layout-login-logout-links">代码清单 8.16</a> 和<a href="#listing-bootstrap-js">代码清单 8.17</a> 中的代码后，应该能看到下拉菜单和只有已登录用户才能看到的链接，如<a href="#fig-profile-with-logout-link">图 8.8</a> 所示。如果关闭浏览器，还能确认应用确实忘了登录状态，必须再次登录才能看到上述改动。</p>
<div id="fig-profile-with-logout-link" class="figure"><img src="images/chapter8/profile_with_logout_link_3rd_edition.png" alt="profile with logout link 3rd edition" /><div class="figcaption"><span class="title-label">图 8.8</span>：用户登录后看到了新添加的链接和下拉菜单</div></div>
</section>
<section data-type="sect2" id="testing-layout-changes">
<h2><span class="title-label">8.2.4</span> 测试布局中的变化</h2>
<p>我们自己动手验证了成功登录后应用的表现正常，在继续之前，还要编写集成测试检查这些行为，以及捕获回归。我们要在<a href="#listing-flash-persistence-test">代码清单 8.7</a>的基础上，再添加一些测试，检查下面的操作步骤：</p>
<ol class="arabic">
<li>
<p>访问登录页面；</p>
</li>
<li>
<p>通过 <code>post</code> 请求发送有效的登录信息；</p>
</li>
<li>
<p>确认登录链接消失了；</p>
</li>
<li>
<p>确认出现了退出链接；</p>
</li>
<li>
<p>确认出现了资料页面链接。</p>
</li>
</ol>
<p>为了检查这些变化，在测试中要登入已经注册的用户，也就是说数据库中必须有一个用户。Rails 默认使用“固件”实现这种需求。固件是一种组织数据的方式，这些数据会载入测试数据库。<a href="chapter6.html#uniqueness-validation">6.2.5 节</a>删除了默认生成的固件（<a href="chapter6.html#listing-empty-fixtures">代码清单 6.30</a>），目的是让检查电子邮件地址的测试通过。现在，我们要在这个空文件中加入自定义的固件。</p>
<p>目前，我们只需要一个用户，它的名字和电子邮件地址应该是有效的。因为我们要登入这个用户，所以还要提供正确的密码，和提交给会话控制器中 <code>create</code> 动作的密码比较。参照<a href="chapter6.html#fig-user-model-password-digest">图 6.7</a> 中的数据模型，可以看出，我们要在用户固件中定义 <code>password_digest</code> 属性。我们会定义 <code>digest</code> 方法计算这个属性的值。</p>
<p><a href="chapter6.html#a-hashed-password">6.3.1 节</a>说过，密码摘要使用 bcrypt 生成（通过 <code>has_secure_password</code> 方法），所以固件中的密码摘要也要使用这种方法生成。查看<a href="https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb">安全密码的源码</a>后，我们发现生成摘要的方法是：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="ss">cost</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span>
</pre></div>
</div>
<p>其中，<code>string</code> 是要计算哈希值的字符串；<code>cost</code> 是“耗时因子”，决定计算哈希值时消耗的资源。耗时因子的值越大，由哈希值破解出原密码的难度越大。这个值对生产环境的安全防护很重要，但在测试中我们希望 <code>digest</code> 方法的执行速度越快越好。安全密码的源码中还有这么一行代码：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">cost</span> <span class="o">=</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">SecurePassword</span><span class="o">.</span><span class="n">min_cost</span> <span class="p">?</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">::</span><span class="no">MIN_COST</span> <span class="p">:</span>
                                              <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">.</span><span class="n">cost</span>
</pre></div>
</div>
<p>这行代码相当难懂，你无须完全理解，它的作用是严格实现前面的分析：在测试中耗时因子使用最小值，在生产环境则使用普通（最大）值。（<a href="chapter8.html#remember-me-checkbox">8.4.5 节</a>会深入介绍奇怪的 <code>?-:</code> 写法。）</p>
<p><code>digest</code> 方法可以放在几个不同的地方，但 <a href="#remember-token-and-digest">8.4.1 节</a>会在用户模型中使用，所以建议放在 <code>user.rb</code> 中。因为计算摘要时不用获取用户对象，所以我们要把 <code>digest</code> 方法附在 <code>User</code> 类上，也就是定义为类方法（<a href="chapter4.html#constructors">4.4.1 节</a>简要介绍过）。结果如<a href="#listing-digest-method">代码清单 8.18</a> 所示。</p>
<div id="listing-digest-method" data-type="listing">
<h5><span class="title-label">代码清单 8.18</span>：定义固件中要使用的 <code>digest</code> 方法</h5>

<div class="source-file">app/models/user.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">before_save</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">255</span> <span class="p">},</span>
                    <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness</span><span class="p">:</span> <span class="p">{</span> <span class="ss">case_sensitive</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="n">has_secure_password</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">minimum</span><span class="p">:</span> <span class="mi">6</span> <span class="p">}</span>

  <span class="c1"># 返回指定字符串的哈希摘要</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">digest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="hll">    <span class="n">cost</span> <span class="o">=</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">SecurePassword</span><span class="o">.</span><span class="n">min_cost</span> <span class="p">?</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">::</span><span class="no">MIN_COST</span> <span class="p">:</span>
</span><span class="hll">                                                  <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">.</span><span class="n">cost</span>
</span><span class="hll">    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="ss">cost</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>定义好 <code>digest</code> 方法后，我们可以创建一个有效的用户固件了，如<a href="#listing-real-user-fixture">代码清单 8.19</a> 所示。</p>
<div id="listing-real-user-fixture" data-type="listing">
<h5><span class="title-label">代码清单 8.19</span>：测试用户登录所需的固件</h5>

<div class="source-file">test/fixtures/users.yml</div>

<div class="highlight language-yaml"><pre><span class="l-Scalar-Plain">michael</span><span class="p-Indicator">:</span>
  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Michael Example</span>
  <span class="l-Scalar-Plain">email</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">michael@example.com</span>
  <span class="l-Scalar-Plain">password_digest</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">&lt;%= User.digest('password') %&gt;</span>
</pre></div>
</div>
<p>特别注意一下，固件中可以使用嵌入式 Ruby。因此，我们可以使用</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="no">User</span><span class="o">.</span><span class="n">digest</span><span class="p">(</span><span class="s1">'password'</span><span class="p">)</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>生成测试用户正确的密码摘要。</p>
<p>我们虽然定义了 <code>has_secure_password</code> 所需的 <code>password_digest</code> 属性，但有时也需要使用密码的原始值。可是，在固件中无法实现，如果在<a href="#listing-real-user-fixture">代码清单 8.19</a> 中添加 <code>password</code> 属性，Rails 会提示数据库中没有这个列（确实没有）。所以，我们约定固件中所有用户的密码都一样，即 <code>'password'</code>。</p>
<p>创建了一个有效用户固件后，在测试中可以使用下面的方式获取这个用户：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">user</span> <span class="o">=</span> <span class="n">users</span><span class="p">(</span><span class="ss">:michael</span><span class="p">)</span>
</pre></div>
</div>
<p>其中，<code>users</code> 对应固件文件 <code>users.yml</code> 的文件名，<code>:michael</code> 是<a href="#listing-real-user-fixture">代码清单 8.19</a> 中定义的用户。</p>
<p>定义好用户固件之后，现在可以把本节开头列出的操作步骤转换成代码了，如<a href="#listing-user-login-test-valid-information">代码清单 8.20</a> 所示。（注意，这段代码中的 <code>get</code> 和 <code>post</code> 两步严格来说没有关系，其实向控制器发起 <code>POST</code> 请求之前没必要向登录页面发起 <code>GET</code> 请求。我之所以加入这一步是为了明确表明操作步骤，以及确认渲染登录表单时没有错误。）</p>
<div id="listing-user-login-test-valid-information" data-type="listing">
<h5><span class="title-label">代码清单 8.20</span>：测试使用有效信息登录的情况 <span class="green">GREEN</span></h5>

<div class="source-file">test/integration/users_login_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">UsersLoginTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>

<span class="hll">  <span class="k">def</span> <span class="nf">setup</span>
</span><span class="hll">    <span class="vi">@user</span> <span class="o">=</span> <span class="n">users</span><span class="p">(</span><span class="ss">:michael</span><span class="p">)</span>
</span><span class="hll">  <span class="k">end</span>
</span>  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="nb">test</span> <span class="s2">"login with valid information"</span> <span class="k">do</span>
    <span class="n">get</span> <span class="n">login_path</span>
    <span class="n">post</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">session</span><span class="p">:</span> <span class="p">{</span> <span class="ss">email</span><span class="p">:</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">,</span> <span class="ss">password</span><span class="p">:</span> <span class="s1">'password'</span> <span class="p">}</span>
    <span class="n">assert_redirected_to</span> <span class="vi">@user</span>
    <span class="n">follow_redirect!</span>
    <span class="n">assert_template</span> <span class="s1">'users/show'</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">count</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">logout_path</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>在这段代码中，我们使用 <code>assert_redirected_to @user</code> 检查重定向的地址是否正确；使用 <code>follow_redirect!</code> 访问重定向的目标地址。还确认页面中有零个登录链接，从而确认登录链接消失了：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">count</span><span class="p">:</span> <span class="mi">0</span>
</pre></div>
</div>
<p><code>count: 0</code> 参数的目的是，告诉 <code>assert_select</code>，我们期望页面中有零个匹配指定模式的链接。（<a href="chapter5.html#listing-layout-links-test">代码清单 5.25</a>中使用的是 <code>count: 2</code>，指定必须有两个匹配模式的链接。）</p>
<p>因为应用代码已经能正常运行，所以这个测试应该可以通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.21</span>：<strong class="green">GREEN</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test </span><span class="nv">TEST</span><span class="o">=</span><span class="nb">test</span>/integration/users_login_test.rb <span class="se">\</span>
&gt;                       <span class="nv">TESTOPTS</span><span class="o">=</span><span class="s2">"--name test_login_with_valid_information"</span>
</pre></div>
</div>
<p>上述命令说明了如何运行一个测试文件中的某个测试——使用如下参数，并指定测试的名字：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">TESTOPTS</span><span class="o">=</span><span class="s2">"--name test_login_with_valid_information"</span>
</pre></div>
</div>
<p>（测试的名字是使用下划线把“test”和测试说明连接在一起。）</p>
</section>
<section data-type="sect2" id="login-upon-signup">
<h2><span class="title-label">8.2.5</span> 注册后直接登录</h2>
<p>虽然现在基本完成了认证功能，但是新注册的用户可能还是会困惑，为什么注册后没有登录呢。注册后立即要求用户登录是很奇怪的，所以我们要在注册的过程中自动登入用户。为了实现这一功能，我们只需在用户控制器的 <code>create</code> 动作中调用 <code>log_in</code> 方法，如<a href="#listing-login-upon-signup">代码清单 8.22</a> 所示。<sup>[<a id="fn-ref-11" href="#fn-11">11</a>]</sup></p>
<div id="listing-login-upon-signup" data-type="listing">
<h5><span class="title-label">代码清单 8.22</span>：注册后登入用户</h5>

<div class="source-file">app/controllers/users_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">new</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">user_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="vi">@user</span><span class="o">.</span><span class="n">save</span>
<span class="hll">      <span class="n">log_in</span> <span class="vi">@user</span>
</span>      <span class="n">flash</span><span class="o">[</span><span class="ss">:success</span><span class="o">]</span> <span class="o">=</span> <span class="s2">"Welcome to the Sample App!"</span>
      <span class="n">redirect_to</span> <span class="vi">@user</span>
    <span class="k">else</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">user_params</span>
      <span class="n">params</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span><span class="o">.</span><span class="n">permit</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">,</span>
                                   <span class="ss">:password_confirmation</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>为了测试这个功能，我们可以在<a href="chapter7.html#listing-a-test-for-valid-submission">代码清单 7.26</a> 中添加一行代码，检查用户是否已经登录。我们可以定义一个 <code>is_logged_in?</code> 辅助方法，功能和<a href="#listing-logged-in-p">代码清单 8.15</a> 中的 <code>logged_in?</code> 方法一样，如果（测试环境的）会话中有用户的 ID 就返回 <code>true</code>，否则返回 <code>false</code>，如<a href="#listing-test-helper-sessions">代码清单 8.23</a> 所示。（我们不能像<a href="#listing-logged-in-p">代码清单 8.15</a> 那样使用 <code>current_user</code>，因为在测试中不能使用 <code>current_user</code> 方法，但是可以使用 <code>session</code> 方法。）我们定义的方法不是 <code>logged_in?</code>，而是 <code>is_logged_in?</code>——测试辅助方法和会话辅助方法名字不一样，以免混淆。<sup>[<a id="fn-ref-12" href="#fn-12">12</a>]</sup></p>
<div id="listing-test-helper-sessions" data-type="listing">
<h5><span class="title-label">代码清单 8.23</span>：在测试中定义检查登录状态的方法，返回布尔值</h5>

<div class="source-file">test/test_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="no">ENV</span><span class="o">[</span><span class="s1">'RAILS_ENV'</span><span class="o">]</span> <span class="o">||=</span> <span class="s1">'test'</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="k">class</span> <span class="nc">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="n">fixtures</span> <span class="ss">:all</span>

  <span class="c1"># 如果用户已登录，返回 true</span>
<span class="hll">  <span class="k">def</span> <span class="nf">is_logged_in?</span>
</span><span class="hll">    <span class="o">!</span><span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">].</span><span class="n">nil?</span>
</span><span class="hll">  <span class="k">end</span>
</span><span class="k">end</span>
</pre></div>
</div>
<p>然后，我们可以使用<a href="#listing-login-after-signup-test">代码清单 8.24</a> 中的测试检查注册后用户有没有登录。</p>
<div id="listing-login-after-signup-test" data-type="listing">
<h5><span class="title-label">代码清单 8.24</span>：测试注册后有没有登入用户 <span class="green">GREEN</span></h5>

<div class="source-file">test/integration/users_signup_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">UsersSignupTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="nb">test</span> <span class="s2">"valid signup information"</span> <span class="k">do</span>
    <span class="n">get</span> <span class="n">signup_path</span>
    <span class="n">assert_difference</span> <span class="s1">'User.count'</span><span class="p">,</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">post_via_redirect</span> <span class="n">users_path</span><span class="p">,</span> <span class="ss">user</span><span class="p">:</span> <span class="p">{</span> <span class="nb">name</span><span class="p">:</span>  <span class="s2">"Example User"</span><span class="p">,</span>
                                            <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
                                            <span class="ss">password</span><span class="p">:</span>              <span class="s2">"password"</span><span class="p">,</span>
                                            <span class="ss">password_confirmation</span><span class="p">:</span> <span class="s2">"password"</span> <span class="p">}</span>
    <span class="k">end</span>
    <span class="n">assert_template</span> <span class="s1">'users/show'</span>
<span class="hll">    <span class="n">assert</span> <span class="n">is_logged_in?</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在，测试组件应该可以通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.25</span>：<strong class="green">GREEN</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
</section>
</section>
<section data-type="sect1" id="logging-out">
<h1><span class="title-label">8.3</span> 退出</h1>
<p><a href="#sessions">8.1 节</a>说过，我们要实现的认证系统会记住用户的登录状态，直到用户自行退出为止。本节，我们就要实现退出功能。退出链接已经定义好了（<a href="#listing-layout-login-logout-links">代码清单 8.16</a>），所以我们只需编写一个正确的控制器动作，销毁用户会话。</p>
<p>目前为止，会话控制器的动作都遵从了 REST 架构，<code>new</code> 动作用于登录页面，<code>create</code> 动作完成登录操作。我们要继续使用 REST 架构，添加一个 <code>destroy</code> 动作，删除会话，实现退出功能。登录功能在<a href="#listing-log-in-success">代码清单 8.13</a> 和<a href="#listing-login-upon-signup">代码清单 8.22</a> 中都用到了，但退出功能不同，只在一处使用，所以我们会直接把相关的代码写在 <code>destroy</code> 动作中。<a href="#remember-tests">8.4.6 节</a>会看到，这么做（稍微重构后）易于测试认证系统。</p>
<p>退出要撤销 <code>log_in</code>（<a href="#listing-log-in-function">代码清单 8.12</a>）完成的操作，即从会话中删除用户的 ID。为此，我们要使用 <code>delete</code> 方法，如下所示：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">)</span>
</pre></div>
</div>
<p>我们还要把当前用户设为 <code>nil</code>。不过在现在这种情况下做不做这一步都没关系，因为退出后会立即转向根地址。<sup>[<a id="fn-ref-13" href="#fn-13">13</a>]</sup>和 <code>log_in</code> 及相关的方法一样，我们要把 <code>log_out</code> 方法放在会话辅助方法模块中，如<a href="#listing-log-out-method">代码清单 8.26</a> 所示。</p>
<div id="listing-log-out-method" data-type="listing">
<h5><span class="title-label">代码清单 8.26</span>：<code>log_out</code> 方法</h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="c1"># 登入指定的用户</span>
  <span class="k">def</span> <span class="nf">log_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="c1"># 退出当前用户</span>
  <span class="k">def</span> <span class="nf">log_out</span>
<span class="hll">    <span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">)</span>
</span><span class="hll">    <span class="vi">@current_user</span> <span class="o">=</span> <span class="kp">nil</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>然后，在会话控制器的 <code>destroy</code> 动作中调用 <code>log_out</code> 方法，如<a href="#listing-destroy-session">代码清单 8.27</a> 所示。</p>
<div id="listing-destroy-session" data-type="listing">
<h5><span class="title-label">代码清单 8.27</span>：销毁会话（退出用户）</h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">].</span><span class="n">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
      <span class="n">log_in</span> <span class="n">user</span>
      <span class="n">redirect_to</span> <span class="n">user</span>
    <span class="k">else</span>
      <span class="n">flash</span><span class="o">.</span><span class="n">now</span><span class="o">[</span><span class="ss">:danger</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
<span class="hll">    <span class="n">log_out</span>
</span><span class="hll">    <span class="n">redirect_to</span> <span class="n">root_url</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们可以在<a href="#listing-user-login-test-valid-information">代码清单 8.20</a> 中的用户登录测试中添加一些步骤，测试退出功能。登录后，使用 <code>delete</code> 方法向退出地址（<a href="#table-restful-sessions">表 8.1</a>）发起 <code>DELETE</code> 请求，然后确认用户已经退出，而且重定向到了根地址。我们还要确认出现了登录链接，而且退出和资料页面的链接消失了。测试中新加入的步骤如<a href="#listing-user-logout-test">代码清单 8.28</a> 所示。</p>
<div id="listing-user-logout-test" data-type="listing">
<h5><span class="title-label">代码清单 8.28</span>：测试用户退出功能 <span class="green">GREEN</span></h5>

<div class="source-file">test/integration/users_login_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">UsersLoginTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="hll">  <span class="nb">test</span> <span class="s2">"login with valid information followed by logout"</span> <span class="k">do</span>
</span>    <span class="n">get</span> <span class="n">login_path</span>
    <span class="n">post</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">session</span><span class="p">:</span> <span class="p">{</span> <span class="ss">email</span><span class="p">:</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">,</span> <span class="ss">password</span><span class="p">:</span> <span class="s1">'password'</span> <span class="p">}</span>
<span class="hll">    <span class="n">assert</span> <span class="n">is_logged_in?</span>
</span>    <span class="n">assert_redirected_to</span> <span class="vi">@user</span>
    <span class="n">follow_redirect!</span>
    <span class="n">assert_template</span> <span class="s1">'users/show'</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">count</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">logout_path</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span>
<span class="hll">    <span class="n">delete</span> <span class="n">logout_path</span>
</span><span class="hll">    <span class="n">assert_not</span> <span class="n">is_logged_in?</span>
</span><span class="hll">    <span class="n">assert_redirected_to</span> <span class="n">root_url</span>
</span><span class="hll">    <span class="n">follow_redirect!</span>
</span><span class="hll">    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">login_path</span>
</span><span class="hll">    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">logout_path</span><span class="p">,</span>      <span class="ss">count</span><span class="p">:</span> <span class="mi">0</span>
</span><span class="hll">    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">),</span> <span class="ss">count</span><span class="p">:</span> <span class="mi">0</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>（现在可以在测试中使用 <code>is_logged_in?</code> 了，所以向登录地址发送有效信息之后，我们添加了 <code>assert is_logged_in?</code>。）</p>
<p>定义并测试了 <code>destroy</code> 动作之后，注册、登录和退出三大功能就都实现了。现在测试组件应该可以通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.29</span>：<strong class="green">GREEN</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
</section>
<section data-type="sect1" id="remember-me">
<h1><span class="title-label">8.4</span> 记住我</h1>
<p><a href="#logging-in">8.2 节</a>实现的登录系统自成一体且功能完整，不过大多数网站还会提供一种功能——用户关闭浏览器后仍能记住用户的会话。本节，我们首先实现自动记住用户会话的功能，只有用户明确退出后会话才会失效。<a href="#remember-me-checkbox">8.4.5 节</a>实现另一种常用方式：提供一个“记住我”复选框，让用户选择是否记住会话。这两种方式都很专业，<a href="http://github.com/">GitHub</a> 和 <a href="http://bitbucket.org/">Bitbucket</a> 等网站使用第一种，<a href="http://www.facebook.com/">Facebook</a> 和 <a href="http://twitter.com/">Twitter</a> 等网站使用第二种。</p>
<section data-type="sect2" id="remember-token-and-digest">
<h2><span class="title-label">8.4.1</span> 记忆令牌和摘要</h2>
<p><a href="#logging-in">8.2 节</a>使用 Rails 中的 <code>session</code> 方法存储用户的 ID，但是浏览器关闭后这个信息就不见了。本节，我们迈出实现持久会话的第一步：生成使用 <code>cookies</code> 方法创建持久 cookie 所需的“记忆令牌”，以及认证令牌所需的安全记忆摘要。</p>
<p><a href="#the-log-in-method">8.2.1 节</a>说过，使用 <code>session</code> 方法存储的信息默认情况下就是安全的，但使用 <code>cookies</code> 方法存储的信息则不然。具体而言，持久 cookie 有被<a href="http://en.wikipedia.org/wiki/Session_hijacking">会话劫持</a>的风险，攻击者可以使用盗取的记忆令牌以某个用户的身份登录。盗取 cookie 中的信息主要有四种方法：（1）使用<a href="https://en.wikipedia.org/wiki/Packet_analyzer">包嗅探</a>工具截获不安全网络中传输的 cookie；<sup>[<a id="fn-ref-14" href="#fn-14">14</a>]</sup>（2）获取包含记忆令牌的数据库；（3）使用“跨站脚本”（Cross-Site Scripting，简称 XSS）攻击；（4）获取已登录用户的设备访问权。我们在 <a href="chapter7.html#professional-grade-deployment">7.5 节</a>启用了全站 SSL，避免嗅探网络中传输的数据，因此解决了第一个问题。为了解决第二个问题，我们不会存储记忆令牌本身，而是存储令牌的哈希摘要——这种方法和 <a href="chapter6.html#adding-a-secure-password">6.3 节</a>一样，不存储原始密码，而是存储密码摘要。Rails 会转义插入视图模板中的内容，所以自动解决了第三个问题。对于最后一个问题，虽然没有万无一失的方法能避免攻击者获取已登录用户电脑的访问权，不过我们可以在每次用户退出后修改令牌，以及签名加密存储在浏览器中的敏感信息，尽量减少第三个问题发生的几率。</p>
<p>经过上述分析，我们计划按照下面的方式实现持久会话：</p>
<ol class="arabic">
<li>
<p>生成随机字符串，当做记忆令牌；</p>
</li>
<li>
<p>把这个令牌存入浏览器的 cookie 中，并把过期时间设为未来的某个日期；</p>
</li>
<li>
<p>在数据库中存储令牌的摘要；</p>
</li>
<li>
<p>在浏览器的 cookie 中存储加密后的用户 ID；</p>
</li>
<li>
<p>如果 cookie 中有用户的 ID，就用这个 ID 在数据库中查找用户，并且检查 cookie 中的记忆令牌和数据库中的哈希摘要是否匹配。</p>
</li>
</ol>
<p>注意，最后一步和登入用户很相似：使用电子邮件地址取回用户，然后（使用 <code>authenticate</code> 方法）验证提交的密码和密码摘要是否匹配（<a href="#listing-find-authenticate-user">代码清单 8.5</a>）。所以，我们的实现方式和 <code>has_secure_password</code> 差不多。</p>
<p>首先，我们把所需的 <code>remember_digest</code> 属性加入用户模型，如<a href="#fig-user-model-remember-digest">图 8.9</a> 所示。</p>
<div id="fig-user-model-remember-digest" class="figure"><img src="images/chapter8/user_model_remember_digest.png" alt="user model remember digest" /><div class="figcaption"><span class="title-label">图 8.9</span>：添加 <code>remember_digest</code> 属性后的用户模型</div></div>
<p>为了把<a href="#fig-user-model-remember-digest">图 8.9</a> 中的数据模型添加到应用中，我们要生成一个迁移：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>rails generate migration add_remember_digest_to_users remember_digest:string
</pre></div>
</div>
<p>（可以和 <a href="chapter6.html#a-hashed-password">6.3.1 节</a>添加密码摘要的迁移比较一下。）和之前的迁移一样，迁移的名字以 <code>_to_users</code> 结尾，这么做是为了告诉 Rails 这个迁移是用来修改 <code>users</code> 表的。因为我们还指定了属性和类型，所以 Rails 会自动为我们生成迁移代码，如<a href="#listing-add-remember-digest-to-users-generated">代码清单 8.30</a> 所示。</p>
<div id="listing-add-remember-digest-to-users-generated" data-type="listing">
<h5><span class="title-label">代码清单 8.30</span>：生成的迁移，用来添加记忆摘要</h5>

<div class="source-file">db/migrate/[timestamp]_add_remember_digest_to_users.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">AddRememberDigestToUsers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">add_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:remember_digest</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们不会通过记忆摘要取回用户，所以没必要在 <code>remember_digest</code> 列上添加索引，因此可以直接使用上述自动生成的迁移：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>
<p>现在我们要决定使用什么做记忆令牌。很多方法基本上都差不多，其实只要是一定长度的随机字符串都行。Ruby 标准库中 <code>SecureRandom</code> 模块的 <code>urlsafe_base64</code> 方法刚好能满足我们的需求。<sup>[<a id="fn-ref-15" href="#fn-15">15</a>]</sup>这个方法返回长度为 22 的随机字符串，包含字符 A-Z、a-z、0-9、“-”和“_”（每一位都有 64 种可能，因此方法名中有“<a href="http://en.wikipedia.org/wiki/Base64">base64</a>”）。典型的 base64 字符串如下所示：</p>
<div data-type="listing">


<div class="highlight language-irb"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="no">SecureRandom</span><span class="o">.</span><span class="n">urlsafe_base64</span>
<span class="go">=&gt; "q5lt38hQDc_959PVoo6b7A"</span>
</pre></div>
</div>
<p>就像两个用户可以使用相同的密码一样，<sup>[<a id="fn-ref-16" href="#fn-16">16</a>]</sup>记忆令牌也没必要是唯一的，不过如果唯一的话，安全性更高。<sup>[<a id="fn-ref-17" href="#fn-17">17</a>]</sup>对 base64 字符串来说，22 个字符中的每一个都有 64 种取值可能，所以两个记忆令牌“碰撞”的几率小到可以忽略，只有 1/64<sup>22</sup> = 2<sup>-132</sup> ≈ 10<sup>-40</sup>。而且，使用可在 URL 中安全使用的 base64 字符串（<code>urlsafe_base64</code> 方法的名字所示），我们还能在账户激活和密码重设链接中使用类似的令牌（<a href="chapter10.html#account-activation-and-password-reset">第 10 章</a>）。</p>
<p>记住用户的登录状态要创建一个记忆令牌，并且在数据库中存储这个令牌的摘要。我们已经定义了 <code>digest</code> 方法，并且在测试固件中用过（<a href="#listing-digest-method">代码清单 8.18</a>）。基于上述分析，现在我们可以定义一个 <code>new_token</code> 方法，创建一个新令牌。和 <code>digest</code> 方法一样，新建令牌的方法也不需要用户对象，所以也定义为类方法，<sup>[<a id="fn-ref-18" href="#fn-18">18</a>]</sup>如<a href="#listing-token-method">代码清单 8.31</a> 所示。</p>
<div id="listing-token-method" data-type="listing">
<h5><span class="title-label">代码清单 8.31</span>：添加生成令牌的方法</h5>

<div class="source-file">app/models/user.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">before_save</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">255</span> <span class="p">},</span>
                    <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness</span><span class="p">:</span> <span class="p">{</span> <span class="ss">case_sensitive</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="n">has_secure_password</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">minimum</span><span class="p">:</span> <span class="mi">6</span> <span class="p">}</span>

  <span class="c1"># 返回指定字符串的哈希摘要</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">digest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">SecurePassword</span><span class="o">.</span><span class="n">min_cost</span> <span class="p">?</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">::</span><span class="no">MIN_COST</span> <span class="p">:</span>
                                                  <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">.</span><span class="n">cost</span>
    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="ss">cost</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># 返回一个随机令牌</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">new_token</span>
<span class="hll">    <span class="no">SecureRandom</span><span class="o">.</span><span class="n">urlsafe_base64</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>我们计划定义 <code>user.remember</code> 方法把记忆令牌和用户关联起来，并且把相应的记忆摘要存入数据库。<a href="#listing-add-remember-digest-to-users-generated">代码清单 8.30</a>中的迁移已经添加了 <code>remember_digest</code> 属性，但是还没有 <code>remember_token</code> 属性。我们要找到一种方法，通过 <code>user.remember_token</code> 获取令牌（为了存入 cookie），但又不在数据库中存储令牌。<a href="chapter6.html#adding-a-secure-password">6.3 节</a>解决过类似的问题——使用虚拟属性 <code>password</code> 和数据库中的 <code>password_digest</code> 属性。其中，虚拟属性 <code>password</code> 由 <code>has_secure_password</code> 方法自动创建。但是，我们要自己编写代码创建 <code>remember_token</code> 属性，方法是使用 <a href="chapter4.html#a-user-class">4.4.5 节</a>用过的 <code>attr_accessor</code>，创建一个可访问的属性：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
<span class="hll">  <span class="kp">attr_accessor</span> <span class="ss">:remember_token</span>
</span>  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="k">def</span> <span class="nf">remember</span>
<span class="hll">    <span class="nb">self</span><span class="o">.</span><span class="n">remember_token</span> <span class="o">=</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class="hll">    <span class="n">update_attribute</span><span class="p">(</span><span class="ss">:remember_digest</span><span class="p">,</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">)</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>注意 <code>remember</code> 方法中第一行代码的赋值操作。根据 Ruby 处理对象内赋值操作的规则，如果没有 <code>self</code>，创建的是一个名为 <code>remember_token</code> 的本地变量——这并不是我们想要的行为。使用 <code>self</code> 的目的是确保把值赋给用户的 <code>remember_token</code> 属性。（现在你应该知道为什么 <code>before_save</code> 回调中要使用 <code>self.email</code>，而不是 <code>email</code> 了吧（<a href="chapter6.html#listing-email-downcase">代码清单 6.31</a>）。）<code>remember</code> 方法的第二行代码使用 <code>update_attribute</code> 方法更新记忆摘要。（<a href="chapter6.html#updating-user-objects">6.1.5 节</a>说过，这个方法会跳过验证。这里必须跳过验证，因为我们无法获取用户的密码和密码确认。）</p>
<p>基于上述分析，创建有效令牌和摘要的方法是：首先使用 <code>User.new_token</code> 创建一个新记忆令牌，然后使用 <code>User.digest</code> 生成摘要，再更新数据库中的记忆摘要。实现这个步骤的 <code>remember</code> 方法如<a href="#listing-user-model-remember">代码清单 8.32</a> 所示。</p>
<div id="listing-user-model-remember" data-type="listing">
<h5><span class="title-label">代码清单 8.32</span>：在用户模型中添加 <code>remember</code> 方法 <span class="green">GREEN</span></h5>

<div class="source-file">app/models/user.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
<span class="hll">  <span class="kp">attr_accessor</span> <span class="ss">:remember_token</span>
</span>  <span class="n">before_save</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">255</span> <span class="p">},</span>
                    <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness</span><span class="p">:</span> <span class="p">{</span> <span class="ss">case_sensitive</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="n">has_secure_password</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">minimum</span><span class="p">:</span> <span class="mi">6</span> <span class="p">}</span>

  <span class="c1"># 返回指定字符串的哈希摘要</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">digest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">SecurePassword</span><span class="o">.</span><span class="n">min_cost</span> <span class="p">?</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">::</span><span class="no">MIN_COST</span> <span class="p">:</span>
                                                  <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">.</span><span class="n">cost</span>
    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="ss">cost</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># 返回一个随机令牌</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">new_token</span>
    <span class="no">SecureRandom</span><span class="o">.</span><span class="n">urlsafe_base64</span>
  <span class="k">end</span>

  <span class="c1"># 为了持久会话，在数据库中记住用户</span>
  <span class="k">def</span> <span class="nf">remember</span>
<span class="hll">    <span class="nb">self</span><span class="o">.</span><span class="n">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new_token</span>
</span><span class="hll">    <span class="n">update_attribute</span><span class="p">(</span><span class="ss">:remember_digest</span><span class="p">,</span> <span class="no">User</span><span class="o">.</span><span class="n">digest</span><span class="p">(</span><span class="n">remember_token</span><span class="p">))</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
</section>
<section data-type="sect2" id="login-with-remembering">
<h2><span class="title-label">8.4.2</span> 登录时记住登录状态</h2>
<p>定义好 <code>user.remember</code> 方法之后，我们可以创建持久会话了，方法是，把（加密后的）用户 ID和记忆令牌作为持久 cookie 存入浏览器。为此，我们要使用 <code>cookies</code> 方法。这个方法和 <code>session</code> 一样，可以视为一个哈希。一个 cookie 有两部分信息，一个是 <code>value</code>（值），一个是可选的 <code>expires</code>（过期日期）。例如，我们可以创建一个值为记忆令牌，20 年后过期的 cookie，实现持久会话：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">value</span><span class="p">:</span>   <span class="n">remember_token</span><span class="p">,</span>
                             <span class="ss">expires</span><span class="p">:</span> <span class="mi">20</span><span class="o">.</span><span class="n">years</span><span class="o">.</span><span class="n">from_now</span><span class="o">.</span><span class="n">utc</span> <span class="p">}</span>
</pre></div>
</div>
<p>（这里使用了一个便利的 Rails 时间辅助方法，参见<a href="#aside-time-helpers">旁注 8.2</a>。 ）Rails 应用中经常使用 20 年后过期的 cookie，所以 Rails 提供了一个特殊的方法 <code>permanent</code>，用于创建这种 cookie，所以上述代码可以简写为：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">cookies</span><span class="o">.</span><span class="n">permanent</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span> <span class="o">=</span> <span class="n">remember_token</span>
</pre></div>
</div>
<p>这样写，Rails 会自动把过期时间设为 <code>20.years.from_now</code>。</p>
<div data-type="sidebar" id="aside-time-helpers" class="sidebar">
<h5><span class="title-label">旁注 8.2</span>：cookie 在 <code>20.years.from_now</code> 之后过期</h5>
<p>你可能还记得，<a href="chapter4.html#class-inheritance">4.4.2 节</a>说过，可以向任何 Ruby 类，甚至是内置的类中添加自定义的方法。那一节，我们向 <code>String</code> 类添加了 <code>palindrome?</code> 方法（而且还发现了 <code>"deified"</code> 是回文）。我们还介绍过，Rails 为 <code>Object</code> 类添加了 <code>blank?</code> 方法（所以，<code>"".blank?</code>、<code>" ".blank?</code> 和 <code>nil.blank?</code> 的返回值都是 <code>true</code>）。创建 <code>20.years.from_now</code> 之后过期的 cookie 的 <code>cookies.permanent</code> 方法又是一例。<code>permanent</code> 方法使用了 Rails 提供的一个时间辅助方法。时间辅助方法添加到 <code>Fixnum</code> 类（整数的基类）中：</p>
<div data-type="listing">


<div class="highlight language-irb"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="mi">1</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">from_now</span>
<span class="go">=&gt; Sun, 09 Aug 2015 16:48:17 UTC +00:00</span>
<span class="gp">&gt;&gt; </span><span class="mi">10</span><span class="o">.</span><span class="n">weeks</span><span class="o">.</span><span class="n">ago</span>
<span class="go">=&gt; Sat, 31 May 2014 16:48:45 UTC +00:00</span>
</pre></div>
</div>
<p>Rails 还在 <code>Fixnum</code> 类中添加了其他辅助方法：</p>
<div data-type="listing">


<div class="highlight language-irb"><pre><span class="gp">&gt;&gt; </span><span class="mi">1</span><span class="o">.</span><span class="n">kilobyte</span>
<span class="go">=&gt; 1024</span>
<span class="gp">&gt;&gt; </span><span class="mi">5</span><span class="o">.</span><span class="n">megabytes</span>
<span class="go">=&gt; 5242880</span>
</pre></div>
</div>
<p>这几个辅助方法可用于验证文件上传，例如，限制上传的图片最大不超过 <code>5.megabytes</code>。</p>
<p>这种为内置类添加方法的特性很灵便，可以扩展 Ruby 的功能，不过使用时要小心一些。其实 Rails 的很多优雅之处正是基于 Ruby 语言的这一特性实现的。</p>
</div>
<p>我们可以参照 <code>session</code> 方法，使用下面的方式把用户的 ID 存入 cookie：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">cookies</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p>但是这种方式存储的是纯文本，因此攻击者很容易窃取用户的账户。为了避免这种问题，我们要对 cookie 签名，存入浏览器之前安全加密 cookie：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p>因为我们想让用户 ID 和永久的记忆令牌配对，所以也要永久存储用户 ID。为此，我们可以串联调用 <code>signed</code> 和 <code>permanent</code> 方法：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">cookies</span><span class="o">.</span><span class="n">permanent</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p>存储 cookie 后，再访问页面时可以使用下面的代码取回用户：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p>其中，<code>cookies.signed[:user_id]</code> 会自动解密 cookie 中的用户 ID。然后，再使用 bcrypt 确认 <code>cookies[:remember_token]</code> 和 <a href="#listing-user-model-remember">代码清单 8.32</a> 生成的 <code>remember_digest</code> 是否匹配。（你可能想知道为什么不能只使用签名的用户 ID。如果没有记忆令牌，攻击者一旦知道加密的 ID，就能以这个用户的身份登录。但是按照我们目前的设计方式，就算攻击者同时获得了用户 ID 和记忆令牌，也要等到用户退出后才能登录。）</p>
<p>最后一步是，确认记忆令牌匹配用户的记忆摘要。对现在这种情况来说，使用 bcrypt 确认是否匹配有很多等效的方法。如果查看<a href="https://github.com/rails/rails/blob/master/activemodel/lib/active_model/secure_password.rb">安全密码的源码</a>，会发现下面这个比较语句：<sup>[<a id="fn-ref-19" href="#fn-19">19</a>]</sup></p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">password_digest</span><span class="p">)</span> <span class="o">==</span> <span class="n">unencrypted_password</span>
</pre></div>
</div>
<p>这里，我们需要的代码如下：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">remember_digest</span><span class="p">)</span> <span class="o">==</span> <span class="n">remember_token</span>
</pre></div>
</div>
<p>仔细想一想，这行代码有点儿奇怪：看起来是直接比较 bcrypt 计算得到的密码哈希和令牌，那么，要使用 <code>==</code> 就得解密摘要。可是，使用 bcrypt 的目的是为了得到不可逆的哈希值，所以这么想是不对的。研究 <a href="https://github.com/codahale/bcrypt-ruby/blob/master/lib/bcrypt/password.rb">bcrypt gem 的源码</a>后，你会发现 bcrypt 重定义了 <code>==</code>，上述代码其实等效于：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">remember_digest</span><span class="p">)</span><span class="o">.</span><span class="n">is_password?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
</pre></div>
</div>
<p>这种写法没使用 <code>==</code>，而是使用返回布尔值的 <code>is_password?</code> 方法进行比较。因为这么写意思更明确，所以，在应用代码中我们就这么写。</p>
<p>基于上述分析，我们可以在用户模型中定义 <code>authenticated?</code> 方法，比较摘要和令牌。这个方法的作用类似于 <code>has_secure_password</code> 提供用来认证用户的 <code>authenticate</code> 方法（<a href="#listing-log-in-success">代码清单 8.13</a>）。<code>authenticated?</code> 方法的定义如<a href="#listing-authenticated-p">代码清单 8.33</a> 所示。</p>
<div id="listing-authenticated-p" data-type="listing">
<h5><span class="title-label">代码清单 8.33</span>：在用户模型中添加 <code>authenticated?</code> 方法</h5>

<div class="source-file">app/models/user.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">attr_accessor</span> <span class="ss">:remember_token</span>
  <span class="n">before_save</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">255</span> <span class="p">},</span>
                    <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness</span><span class="p">:</span> <span class="p">{</span> <span class="ss">case_sensitive</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="n">has_secure_password</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">minimum</span><span class="p">:</span> <span class="mi">6</span> <span class="p">}</span>

  <span class="c1"># 返回指定字符串的哈希摘要</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">digest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">SecurePassword</span><span class="o">.</span><span class="n">min_cost</span> <span class="p">?</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">::</span><span class="no">MIN_COST</span> <span class="p">:</span>
                                                  <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">.</span><span class="n">cost</span>
    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="ss">cost</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># 返回一个随机令牌</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">new_token</span>
    <span class="no">SecureRandom</span><span class="o">.</span><span class="n">urlsafe_base64</span>
  <span class="k">end</span>

  <span class="c1"># 为了持久会话，在数据库中记住用户</span>
  <span class="k">def</span> <span class="nf">remember</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new_token</span>
    <span class="n">update_attribute</span><span class="p">(</span><span class="ss">:remember_digest</span><span class="p">,</span> <span class="no">User</span><span class="o">.</span><span class="n">digest</span><span class="p">(</span><span class="n">remember_token</span><span class="p">))</span>
  <span class="k">end</span>

  <span class="c1"># 如果指定的令牌和摘要匹配，返回 true</span>
  <span class="k">def</span> <span class="nf">authenticated?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
<span class="hll">    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">remember_digest</span><span class="p">)</span><span class="o">.</span><span class="n">is_password?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>虽然<a href="#listing-authenticated-p">代码清单 8.33</a> 中的 <code>authenticated?</code> 方法和记忆令牌联系紧密，不过在其他情况下也很有用，<a href="chapter10.html#account-activation-and-password-reset">第 10 章</a>会改写这个方法，让它的使用范围更广。</p>
<p>现在可以记住用户的登录状态了。我们要在 <code>log_in</code> 后面调用 <code>remember</code> 辅助方法，如<a href="#listing-log-in-with-remember">代码清单 8.34</a> 所示。</p>
<div id="listing-log-in-with-remember" data-type="listing">
<h5><span class="title-label">代码清单 8.34</span>：登录并记住登录状态</h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">].</span><span class="n">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
      <span class="n">log_in</span> <span class="n">user</span>
<span class="hll">      <span class="n">remember</span> <span class="n">user</span>
</span>      <span class="n">redirect_to</span> <span class="n">user</span>
    <span class="k">else</span>
      <span class="n">flash</span><span class="o">.</span><span class="n">now</span><span class="o">[</span><span class="ss">:danger</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
    <span class="n">log_out</span>
    <span class="n">redirect_to</span> <span class="n">root_url</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>和登录功能一样，<a href="#listing-log-in-with-remember">代码清单 8.34</a> 把真正的工作交给会话辅助方法完成。在会话辅助方法模块中，我们要定义一个名为 <code>remember</code> 的方法，调用 <code>user.remember</code>，从而生成一个记忆令牌，并把对应的摘要存入数据库；然后使用 <code>cookies</code> 创建永久 cookie，保存用户 ID 和记忆令牌。结果如<a href="#listing-remember-method">代码清单 8.35</a> 所示。</p>
<div id="listing-remember-method" data-type="listing">
<h5><span class="title-label">代码清单 8.35</span>：记住用户</h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="c1"># 登入指定的用户</span>
  <span class="k">def</span> <span class="nf">log_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
  <span class="k">end</span>

  <span class="c1"># 在持久会话中记住用户</span>
  <span class="k">def</span> <span class="nf">remember</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="hll">    <span class="n">user</span><span class="o">.</span><span class="n">remember</span>
</span><span class="hll">    <span class="n">cookies</span><span class="o">.</span><span class="n">permanent</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
</span><span class="hll">    <span class="n">cookies</span><span class="o">.</span><span class="n">permanent</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">remember_token</span>
</span>  <span class="k">end</span>

  <span class="c1"># 返回当前登录的用户（如果有的话）</span>
  <span class="k">def</span> <span class="nf">current_user</span>
    <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># 如果用户已登录，返回 true，否则返回 false</span>
  <span class="k">def</span> <span class="nf">logged_in?</span>
    <span class="o">!</span><span class="n">current_user</span><span class="o">.</span><span class="n">nil?</span>
  <span class="k">end</span>

  <span class="c1"># 退出当前用户</span>
  <span class="k">def</span> <span class="nf">log_out</span>
    <span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">)</span>
    <span class="vi">@current_user</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在，用户登录后会被记住，因为在浏览器中存储了有效的记忆令牌。但是还没有什么实际作用，因为<a href="#listing-current-user">代码清单 8.14</a>中定义的 <code>current_user</code> 方法只能处理临时会话：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p>对持久会话来说，如果临时会话中有 <code>session[:user_id]</code>，那么就从中取回用户，否则，应该检查 <code>cookies[:user_id]</code>，取回（并且登入）持久会话中存储的用户。实现方式如下：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span>
  <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
<span class="k">elsif</span> <span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span>
  <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span><span class="p">)</span>
    <span class="n">log_in</span> <span class="n">user</span>
    <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>（这里沿用了 <a href="#listing-find-authenticate-user">代码清单 8.5</a> 中使用的 <code>user &amp;&amp; user.authenticated</code> 模式。）上述代码可以使用，但注意，其中重复使用了 <code>session</code> 和 <code>cookies</code>。我们可以去除重复，写成这样：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="hll"><span class="k">if</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</span>  <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
<span class="hll"><span class="k">elsif</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</span>  <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span><span class="p">)</span>
    <span class="n">log_in</span> <span class="n">user</span>
    <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>改写后使用了常见但有点儿让人困惑的结构：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p>别被外观迷惑了，这不是比较语句（比较时应该使用双等号 <code>==</code>），而是赋值语句。如果读出来，不能念成“如果用户 ID 等于会话中的用户 ID”，应该是“如果会话中有用户的 ID，把会话中的 ID 赋值给 <code>user_id</code>”。<sup>[<a id="fn-ref-20" href="#fn-20">20</a>]</sup></p>
<p>按照上述分析定义 <code>current_user</code> 辅助方法，如<a href="#listing-persistent-current-user">代码清单 8.36</a> 所示。</p>
<div id="listing-persistent-current-user" data-type="listing">
<h5><span class="title-label">代码清单 8.36</span>：更新 <code>current_user</code> 方法，支持持久会话 <span class="red">RED</span></h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="c1"># 登入指定的用户</span>
  <span class="k">def</span> <span class="nf">log_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
  <span class="k">end</span>

  <span class="c1"># 在持久会话中记住用户</span>
  <span class="k">def</span> <span class="nf">remember</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">user</span><span class="o">.</span><span class="n">remember</span>
    <span class="n">cookies</span><span class="o">.</span><span class="n">permanent</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
    <span class="n">cookies</span><span class="o">.</span><span class="n">permanent</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">remember_token</span>
  <span class="k">end</span>

  <span class="c1"># 返回 cookie 中记忆令牌对应的用户</span>
  <span class="k">def</span> <span class="nf">current_user</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</span><span class="hll">      <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
</span><span class="hll">    <span class="k">elsif</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</span><span class="hll">      <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
</span><span class="hll">      <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span><span class="p">)</span>
</span><span class="hll">        <span class="n">log_in</span> <span class="n">user</span>
</span><span class="hll">        <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
</span><span class="hll">      <span class="k">end</span>
</span><span class="hll">    <span class="k">end</span>
</span>  <span class="k">end</span>

  <span class="c1"># 如果用户已登录，返回 true，否则返回 false</span>
  <span class="k">def</span> <span class="nf">logged_in?</span>
    <span class="o">!</span><span class="n">current_user</span><span class="o">.</span><span class="n">nil?</span>
  <span class="k">end</span>

  <span class="c1"># 退出当前用户</span>
  <span class="k">def</span> <span class="nf">log_out</span>
    <span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">)</span>
    <span class="vi">@current_user</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在，新登录的用户能正确记住登录状态了。你可以确认一下：登录后关闭浏览器，再打开浏览器，重新访问演示应用，检查是否还是已登录状态。如果愿意，甚至还可以直接查看浏览器中的 cookie，如<a href="#fig-cookie-in-browser">图 8.10</a> 所示。<sup>[<a id="fn-ref-21" href="#fn-21">21</a>]</sup></p>
<div id="fig-cookie-in-browser" class="figure"><img src="images/chapter8/cookie_in_browser_chrome.png" alt="cookie in browser chrome" /><div class="figcaption"><span class="title-label">图 8.10</span>：本地浏览器 cookie 中存储的记忆令牌</div></div>
<p>现在我们的应用还有一个问题：无法清除浏览器中的 cookie（除非等到 20 年后），因此用户无法退出。这正是测试应该捕获的问题，而且目前测试的确无法通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.37</span>：<strong class="red">RED</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
</section>
<section data-type="sect2" id="forgetting-users">
<h2><span class="title-label">8.4.3</span> 忘记用户</h2>
<p>为了让用户退出，我们要定义一些和记住用户相对的方法，忘记用户。最终实现的 <code>user.forget</code> 方法，把记忆摘要的值设为 <code>nil</code>，即撤销 <code>user.remember</code> 的操作，如<a href="#listing-user-model-forget">代码清单 8.38</a> 所示。</p>
<div id="listing-user-model-forget" data-type="listing">
<h5><span class="title-label">代码清单 8.38</span>：在用户模型中添加 <code>forget</code> 方法</h5>

<div class="source-file">app/models/user.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">attr_accessor</span> <span class="ss">:remember_token</span>
  <span class="n">before_save</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">downcase</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="no">VALID_EMAIL_REGEX</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">maximum</span><span class="p">:</span> <span class="mi">255</span> <span class="p">},</span>
                    <span class="nb">format</span><span class="p">:</span> <span class="p">{</span> <span class="ss">with</span><span class="p">:</span> <span class="no">VALID_EMAIL_REGEX</span> <span class="p">},</span>
                    <span class="ss">uniqueness</span><span class="p">:</span> <span class="p">{</span> <span class="ss">case_sensitive</span><span class="p">:</span> <span class="kp">false</span> <span class="p">}</span>
  <span class="n">has_secure_password</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">presence</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">length</span><span class="p">:</span> <span class="p">{</span> <span class="ss">minimum</span><span class="p">:</span> <span class="mi">6</span> <span class="p">}</span>

  <span class="c1"># 返回指定字符串的哈希摘要</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">digest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">SecurePassword</span><span class="o">.</span><span class="n">min_cost</span> <span class="p">?</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">::</span><span class="no">MIN_COST</span> <span class="p">:</span>
                                                  <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">.</span><span class="n">cost</span>
    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="ss">cost</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># 返回一个随机令牌</span>
  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">new_token</span>
    <span class="no">SecureRandom</span><span class="o">.</span><span class="n">urlsafe_base64</span>
  <span class="k">end</span>

  <span class="c1"># 为了持久会话，在数据库中记住用户</span>
  <span class="k">def</span> <span class="nf">remember</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">remember_token</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new_token</span>
    <span class="n">update_attribute</span><span class="p">(</span><span class="ss">:remember_digest</span><span class="p">,</span> <span class="no">User</span><span class="o">.</span><span class="n">digest</span><span class="p">(</span><span class="n">remember_token</span><span class="p">))</span>
  <span class="k">end</span>

  <span class="c1"># 如果指定的令牌和摘要匹配，返回 true</span>
  <span class="k">def</span> <span class="nf">authenticated?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">remember_digest</span><span class="p">)</span><span class="o">.</span><span class="n">is_password?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># 忘记用户</span>
  <span class="k">def</span> <span class="nf">forget</span>
<span class="hll">    <span class="n">update_attribute</span><span class="p">(</span><span class="ss">:remember_digest</span><span class="p">,</span> <span class="kp">nil</span><span class="p">)</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>然后我们可以定义 <code>forget</code> 辅助方法，忘记持久会话，然后在 <code>log_out</code> 辅助方法中调用 <code>forget</code>，如<a href="#listing-log-out-with-forget">代码清单 8.39</a> 所示。<code>forget</code> 方法先调用 <code>user.forget</code>，然后再从 cookie 中删除 <code>user_id</code> 和 <code>remember_token</code>。</p>
<div id="listing-log-out-with-forget" data-type="listing">
<h5><span class="title-label">代码清单 8.39</span>：退出持久会话</h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>

  <span class="c1"># 登入指定的用户</span>
  <span class="k">def</span> <span class="nf">log_in</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="c1"># 忘记持久会话</span>
  <span class="k">def</span> <span class="nf">forget</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="hll">    <span class="n">user</span><span class="o">.</span><span class="n">forget</span>
</span><span class="hll">    <span class="n">cookies</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">)</span>
</span><span class="hll">    <span class="n">cookies</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:remember_token</span><span class="p">)</span>
</span>  <span class="k">end</span>

  <span class="c1"># 退出当前用户</span>
  <span class="k">def</span> <span class="nf">log_out</span>
<span class="hll">    <span class="n">forget</span><span class="p">(</span><span class="n">current_user</span><span class="p">)</span>
</span>    <span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">)</span>
    <span class="vi">@current_user</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
</section>
<section data-type="sect2" id="two-subtle-bugs">
<h2><span class="title-label">8.4.4</span> 两个小问题</h2>
<p>现在还有两个相互之间有关系的小问题要解决。第一个，虽然只有登录后才能看到退出链接，但一个用户可能会同时打开多个浏览器窗口访问网站，如果用户在一个窗口中退出了，再在另一个窗口中点击退出链接的话会导致错误，因为<a href="#listing-log-out-with-forget">代码清单 8.39</a> 中使用了 <code>current_user</code>。<sup>[<a id="fn-ref-22" href="#fn-22">22</a>]</sup>我们可以限制只有已登录的用户才能退出，解决这个问题。</p>
<p>第二个问题，用户可能会在不同的浏览器中登录（登录状态也被记住），例如 Chrome 和 Firefox，如果用户在一个浏览器中退出，而另一个浏览器中没有退出，就会导致问题。<sup>[<a id="fn-ref-23" href="#fn-23">23</a>]</sup>假如用户在 Firefox 中退出了，那么记忆摘要的值变成了 <code>nil</code>（通过<a href="#listing-user-model-forget">代码清单 8.38</a> 中的 <code>user.forget</code>）。在 Firefox 中没什么问题，因为<a href="#listing-log-out-with-forget">代码清单 8.39</a> 中的 <code>log_out</code> 方法删除了用户的 ID，所以在 <code>current_user</code> 方法中，<code>user</code> 变量的值是 <code>nil</code>：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="c1"># 返回 cookie 中记忆令牌对应的用户</span>
<span class="k">def</span> <span class="nf">current_user</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
    <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
<span class="hll">    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
</span>    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span><span class="p">)</span>
      <span class="n">log_in</span> <span class="n">user</span>
      <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>那么，基于短路计算原则，表达式</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p>的值是 <code>false</code>。（因为 <code>user</code> 是 <code>nil</code>，是假值，所以不会再执行第二个表达式。）而在 Chrome 中，用户 ID 没被删除，所以 <code>user</code> 的值不是 <code>nil</code>，所以会执行第二个表达式。这意味着，在 <code>authenticated?</code> 方法（<a href="#listing-authenticated-p">代码清单 8.33</a>）中</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">def</span> <span class="nf">authenticated?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
  <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">remember_digest</span><span class="p">)</span><span class="o">.</span><span class="n">is_password?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p><code>remember_digest</code> 的值是 <code>nil</code>，所以调用 <code>BCrypt::Password.new(remember_digest)</code> 时会抛出异常。而遇到这种情况时，我们希望 <code>authenticated?</code> 方法返回 <code>false</code>。</p>
<p>这正是测试驱动开发的优势所在，所以在解决之前，我们先编写测试捕获这两个小问题。我们先让<a href="#listing-user-logout-test">代码清单 8.28</a> 中的集成测试失败，如<a href="#listing-test-double-logout">代码清单 8.40</a> 所示。</p>
<div id="listing-test-double-logout" data-type="listing">
<h5><span class="title-label">代码清单 8.40</span>：测试用户退出 <span class="red">RED</span></h5>

<div class="source-file">test/integration/users_login_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">UsersLoginTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="nb">test</span> <span class="s2">"login with valid information followed by logout"</span> <span class="k">do</span>
    <span class="n">get</span> <span class="n">login_path</span>
    <span class="n">post</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">session</span><span class="p">:</span> <span class="p">{</span> <span class="ss">email</span><span class="p">:</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">,</span> <span class="ss">password</span><span class="p">:</span> <span class="s1">'password'</span> <span class="p">}</span>
    <span class="n">assert</span> <span class="n">is_logged_in?</span>
    <span class="n">assert_redirected_to</span> <span class="vi">@user</span>
    <span class="n">follow_redirect!</span>
    <span class="n">assert_template</span> <span class="s1">'users/show'</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">count</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">logout_path</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span>
    <span class="n">delete</span> <span class="n">logout_path</span>
    <span class="n">assert_not</span> <span class="n">is_logged_in?</span>
    <span class="n">assert_redirected_to</span> <span class="n">root_url</span>
<span class="hll">    <span class="c1"># 模拟用户在另一个窗口中点击退出链接</span>
</span><span class="hll">    <span class="n">delete</span> <span class="n">logout_path</span>
</span>    <span class="n">follow_redirect!</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">login_path</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">logout_path</span><span class="p">,</span>      <span class="ss">count</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">assert_select</span> <span class="s2">"a[href=?]"</span><span class="p">,</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">),</span> <span class="ss">count</span><span class="p">:</span> <span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>第二个 <code>delete logout_path</code> 会抛出异常，因为没有当前用户，由此导致测试组件无法通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.41</span>：<strong class="red">RED</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
<p>在应用代码中，我们只需在 <code>logged_in?</code> 返回 <code>true</code> 时调用 <code>log_out</code> 即可，如<a href="#listing-destroy-forget">代码清单 8.42</a> 所示。</p>
<div id="listing-destroy-forget" data-type="listing">
<h5><span class="title-label">代码清单 8.42</span>：只有登录后才能退出 <span class="green">GREEN</span></h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="k">def</span> <span class="nf">destroy</span>
<span class="hll">    <span class="n">log_out</span> <span class="k">if</span> <span class="n">logged_in?</span>
</span>    <span class="n">redirect_to</span> <span class="n">root_url</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>第二个问题涉及到两种不同的浏览器，在集成测试中很难模拟，不过直接在用户模型层测试很简单。我们只需创建一个没有记忆摘要的用户（<code>setup</code> 方法中定义的 <code>@user</code> 就没有），再调用 <code>authenticated?</code> 方法即可，如<a href="#listing-test-authenticated-invalid-token">代码清单 8.43</a> 所示。（注意，我们直接使用空记忆令牌，因为还没用到这个值之前就会发生错误。）</p>
<div id="listing-test-authenticated-invalid-token" data-type="listing">
<h5><span class="title-label">代码清单 8.43</span>：测试没有摘要时 <code>authenticated?</code> 方法的表现 <span class="red">RED</span></h5>

<div class="source-file">test/models/user_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">UserTest</span> <span class="o">&lt;</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">email</span><span class="p">:</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
                     <span class="ss">password</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">,</span> <span class="ss">password_confirmation</span><span class="p">:</span> <span class="s2">"foobar"</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="nb">test</span> <span class="s2">"authenticated? should return false for a user with nil digest"</span> <span class="k">do</span>
    <span class="n">assert_not</span> <span class="vi">@user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p><code>BCrypt::Password.new(nil)</code> 会抛出异常，所以测试组件不能通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.44</span>：<strong class="red">RED</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
<p>为了修正这个问题，让测试通过，记忆摘要的值为 <code>nil</code> 时，<code>authenticated?</code> 要返回 <code>false</code>，如<a href="#listing-authenticated-p-fixed">代码清单 8.45</a> 所示。</p>
<div id="listing-authenticated-p-fixed" data-type="listing">
<h5><span class="title-label">代码清单 8.45</span>：更新 <code>authenticated?</code>，处理没有记忆摘要的情况 <span class="green">GREEN</span></h5>

<div class="source-file">app/models/user.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="c1"># 如果指定的令牌和摘要匹配，返回 true</span>
  <span class="k">def</span> <span class="nf">authenticated?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
<span class="hll">    <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">remember_digest</span><span class="o">.</span><span class="n">nil?</span>
</span>    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">remember_digest</span><span class="p">)</span><span class="o">.</span><span class="n">is_password?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>如果记忆摘要的值为 <code>nil</code>，会直接返回 <code>return</code> 语句。这种方式经常用到，目的是强调其后的代码会被忽略。等价的代码如下：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="n">remember_digest</span><span class="o">.</span><span class="n">nil?</span>
  <span class="kp">false</span>
<span class="k">else</span>
  <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">remember_digest</span><span class="p">)</span><span class="o">.</span><span class="n">is_password?</span><span class="p">(</span><span class="n">remember_token</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>这样写也行，但我喜欢明确返回的版本，而且也稍微简短一些。</p>
<p>按照<a href="#listing-authenticated-p-fixed">代码清单 8.45</a> 修改之后，测试组件应该可以通过了，说明这两个小问题都解决了：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.46</span>：<strong class="green">GREEN</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
</section>
<section data-type="sect2" id="remember-me-checkbox">
<h2><span class="title-label">8.4.5</span> “记住我”复选框</h2>
<p>至此，我们的应用已经实现了完整且专业的认证系统。最后一步，我们来看一下如何使用“记住我”复选框让用户选择是否记住登录状态。包含这个复选框的登录表单构思图如<a href="#fig-login-remember-me-mockup">图 8.11</a> 所示。</p>
<div id="fig-login-remember-me-mockup" class="figure"><img src="images/chapter8/login_remember_me_mockup.png" alt="login remember me mockup" /><div class="figcaption"><span class="title-label">图 8.11</span>：构思“记住我”复选框</div></div>
<p>为了实现这个构思，我们首先要在登录表单（<a href="#listing-login-form">代码清单 8.2</a>）中添加一个复选框。和标注（label）、文本字段、密码字段和提交按钮一样，复选框也可以使用 Rails 辅助方法创建。不过，为了得到正确的样式，我们要把复选框嵌套在标注中，如下所示：</p>
<div data-type="listing">


<div class="highlight language-erb"><pre><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">label</span> <span class="ss">:remember_me</span><span class="p">,</span> <span class="ss">class</span><span class="p">:</span> <span class="s2">"checkbox inline"</span> <span class="k">do</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">  </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">check_box</span> <span class="ss">:remember_me</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">  &lt;span&gt;Remember me on this computer&lt;/span&gt;</span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>
</div>
<p>把这段代码添加到登录表单后，得到的视图如<a href="#listing-remember-me-checkbox">代码清单 8.47</a> 所示。</p>
<div id="listing-remember-me-checkbox" data-type="listing">
<h5><span class="title-label">代码清单 8.47</span>：在登录表单中添加“记住我”复选框</h5>

<div class="source-file">app/views/sessions/new.html.erb</div>

<div class="highlight language-erb"><pre><span class="cp">&lt;%</span> <span class="n">provide</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="s2">"Log in"</span><span class="p">)</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">&lt;h1&gt;Log in&lt;/h1&gt;</span>

<span class="x">&lt;div class="row"&gt;</span>
<span class="x">  &lt;div class="col-md-6 col-md-offset-3"&gt;</span>
<span class="x">    </span><span class="cp">&lt;%=</span> <span class="n">form_for</span><span class="p">(</span><span class="ss">:session</span><span class="p">,</span> <span class="ss">url</span><span class="p">:</span> <span class="n">login_path</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="cp">%&gt;</span><span class="x"></span>

<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">label</span> <span class="ss">:email</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">email_field</span> <span class="ss">:email</span> <span class="cp">%&gt;</span><span class="x"></span>

<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">label</span> <span class="ss">:password</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">password_field</span> <span class="ss">:password</span> <span class="cp">%&gt;</span><span class="x"></span>

<span class="hll"><span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">label</span> <span class="ss">:remember_me</span><span class="p">,</span> <span class="ss">class</span><span class="p">:</span> <span class="s2">"checkbox inline"</span> <span class="k">do</span> <span class="cp">%&gt;</span><span class="x"></span>
</span><span class="hll"><span class="x">        </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">check_box</span> <span class="ss">:remember_me</span> <span class="cp">%&gt;</span><span class="x"></span>
</span><span class="hll"><span class="x">        &lt;span&gt;Remember me on this computer&lt;/span&gt;</span>
</span><span class="hll"><span class="x">      </span><span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
</span>
<span class="x">      </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">submit</span> <span class="s2">"Log in"</span><span class="p">,</span> <span class="ss">class</span><span class="p">:</span> <span class="s2">"btn btn-primary"</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">    </span><span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>

<span class="x">    &lt;p&gt;New user? </span><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="s2">"Sign up now!"</span><span class="p">,</span> <span class="n">signup_path</span> <span class="cp">%&gt;</span><span class="x">&lt;/p&gt;</span>
<span class="x">  &lt;/div&gt;</span>
<span class="x">&lt;/div&gt;</span>
</pre></div>
</div>
<p><a href="#listing-remember-me-checkbox">代码清单 8.47</a> 中使用了 CSS 类 <code>checkbox</code> 和 <code>inline</code>，Bootstrap 使用这两个类把复选框和文本（“Remember me on this computer”）放在同一行。为了完善样式，我们还要再定义一些 CSS 规则，如<a href="#listing-remember-me-css">代码清单 8.48</a> 所示。得到的登录表单如<a href="#fig-login-form-remember-me">图 8.12</a> 所示。</p>
<div id="listing-remember-me-css" data-type="listing">
<h5><span class="title-label">代码清单 8.48</span>：“记住我”复选框的 CSS 规则</h5>

<div class="source-file">app/assets/stylesheets/custom.css.scss</div>

<div class="highlight language-scss"><pre><span class="nc">.</span>
<span class="nc">.</span>
<span class="nc">.</span>
<span class="o">/*</span> <span class="nt">forms</span> <span class="o">*/</span>
<span class="nc">.</span>
<span class="nc">.</span>
<span class="nc">.</span>
<span class="nc">.checkbox</span> <span class="p">{</span>
  <span class="na">margin-top</span><span class="o">:</span> <span class="mi">-10</span><span class="kt">px</span><span class="p">;</span>
  <span class="na">margin-bottom</span><span class="o">:</span> <span class="mi">10</span><span class="kt">px</span><span class="p">;</span>
  <span class="nt">span</span> <span class="p">{</span>
    <span class="na">margin-left</span><span class="o">:</span> <span class="mi">20</span><span class="kt">px</span><span class="p">;</span>
    <span class="na">font-weight</span><span class="o">:</span> <span class="no">normal</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nn">#session_remember_me</span> <span class="p">{</span>
  <span class="na">width</span><span class="o">:</span> <span class="no">auto</span><span class="p">;</span>
  <span class="na">margin-left</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div id="fig-login-form-remember-me" class="figure"><img src="images/chapter8/login_form_remember_me.png" alt="login form remember me" /><div class="figcaption"><span class="title-label">图 8.12</span>：添加“记住我”复选框后的登录表单</div></div>
<p>修改登录表单后，当用户勾选这个复选框后，要记住用户的登录状态，否则不记住。因为前一节的工作做得很好，现在实现起来只需一行代码就行。提交登录表单后，<code>params</code> 哈希中包含一个基于复选框状态的值（你可以使用有效信息填写登录表单，然后提交，看一下页面底部的调试信息）。如果勾选了复选框，<code>params[:session][:remember_me]</code> 的值是 <code>'1'</code>，否则是 <code>'0'</code>。</p>
<p>我们可以检查 <code>params</code> 哈希中的相关值，根据提交的值决定是否记住用户：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:remember_me</span><span class="o">]</span> <span class="o">==</span> <span class="s1">'1'</span>
  <span class="n">remember</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="k">else</span>
  <span class="n">forget</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>根据<a href="#aside-ternary-operator">旁注 8.3</a> 中的说明，这种 <code>if-then</code> 分支语句可以使用“三元操作符”变成一行：<sup>[<a id="fn-ref-24" href="#fn-24">24</a>]</sup></p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:remember_me</span><span class="o">]</span> <span class="o">==</span> <span class="s1">'1'</span> <span class="p">?</span> <span class="n">remember</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">:</span> <span class="n">forget</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</pre></div>
</div>
<p>在会话控制器的 <code>create</code> 动作中加入这行代码后，得到的是非常简洁的代码，如<a href="#listing-remember-me-ternary">代码清单 8.49</a> 所示。（现在你应该可以理解<a href="#listing-digest-method">代码清单 8.18</a>中使用三元操作符定义 <code>cost</code> 变量的代码了。）</p>
<div id="listing-remember-me-ternary" data-type="listing">
<h5><span class="title-label">代码清单 8.49</span>：处理提交的“记住我”复选框</h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">].</span><span class="n">downcase</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
      <span class="n">log_in</span> <span class="n">user</span>
<span class="hll">      <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:remember_me</span><span class="o">]</span> <span class="o">==</span> <span class="s1">'1'</span> <span class="p">?</span> <span class="n">remember</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">:</span> <span class="n">forget</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</span>      <span class="n">redirect_to</span> <span class="n">user</span>
    <span class="k">else</span>
      <span class="n">flash</span><span class="o">.</span><span class="n">now</span><span class="o">[</span><span class="ss">:danger</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
    <span class="n">log_out</span> <span class="k">if</span> <span class="n">logged_in?</span>
    <span class="n">redirect_to</span> <span class="n">root_url</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>至此，我们的登录系统完成了。你可以在浏览器中勾选或不勾选“记住我”确认一下。</p>
<div data-type="sidebar" id="aside-ternary-operator" class="sidebar">
<h5><span class="title-label">旁注 8.3</span>：世界上有 10 种人</h5>
<p>有一个老笑话，说世界上有 10 种人，懂二进制的人和不懂二进制的人。（这里的 10，在二进制中是 2）同理，我们可以说，世界上有 11 种人，一种人喜欢三元操作符，一种人不喜欢，还有一种人不知道三元操作符是什么。（如果你碰巧是第三种人，稍后就不是了。）</p>
<p>编程一段时间之后，你会发现，最常使用的流程控制之一是下面这种：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="n">boolean?</span>
  <span class="n">do_one_thing</span>
<span class="k">else</span>
  <span class="n">do_something_else</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Ruby 和其他很多语言一样（包括 C/C++，Perl，PHP 和 Java），提供了一种更为简单的表达式来替代这种流程控制结构——三元操作符（之所以这么叫，是因为三元操作符包括三部分）：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">boolean?</span> <span class="p">?</span> <span class="n">do_one_thing</span> <span class="p">:</span> <span class="n">do_something_else</span>
</pre></div>
</div>
<p>三元操作符甚至还可以用来替代赋值操作，所以</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="n">boolean?</span>
  <span class="n">var</span> <span class="o">=</span> <span class="n">foo</span>
<span class="k">else</span>
  <span class="n">var</span> <span class="o">=</span> <span class="n">bar</span>
<span class="k">end</span>
</pre></div>
</div>
<p>可以写成：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">var</span> <span class="o">=</span> <span class="n">boolean?</span> <span class="p">?</span> <span class="n">foo</span> <span class="p">:</span> <span class="n">bar</span>
</pre></div>
</div>
<p>而且，为了方便，函数的返回值也经常使用三元操作符：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">def</span> <span class="nf">foo</span>
  <span class="n">do_stuff</span>
  <span class="n">boolean?</span> <span class="p">?</span> <span class="s2">"bar"</span> <span class="p">:</span> <span class="s2">"baz"</span>
<span class="k">end</span>
</pre></div>
</div>
<p>因为 Ruby 函数的默认返回值是定义体中的最后一个表达式，所以 <code>foo</code> 方法的返回值会根据 <code>boolean?</code> 的结果而不同，不是 <code>"bar"</code> 就是 <code>"baz"</code>。</p>
</div>
</section>
<section data-type="sect2" id="remember-tests">
<h2><span class="title-label">8.4.6</span> 记住登录状态功能的测试</h2>
<p>“记住我”功能虽然可以使用了，但是我们还得编写一些测试，确认表现正常。测试的目的是要捕获实现方式中可能出现的错误，这一点稍后讨论。更重要的原因是，实现持久会话的代码现在完全没有测试。编写测试时要使用一些小技巧，但能得到更强大的测试组件。</p>
<section data-type="sect3" id="testing-the-remember-me-box">
<h3>测试“记住我”复选框</h3>
<p>处理“记住我”复选框时（<a href="#listing-remember-me-ternary">代码清单 8.49</a>），我最初编写的代码是：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:remember_me</span><span class="o">]</span> <span class="p">?</span> <span class="n">remember</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">:</span> <span class="n">forget</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</pre></div>
</div>
<p>而正确的代码应该写成：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:remember_me</span><span class="o">]</span> <span class="o">==</span> <span class="s1">'1'</span> <span class="p">?</span> <span class="n">remember</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">:</span> <span class="n">forget</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
</pre></div>
</div>
<p><code>params[:session][:remember_me]</code> 的值不是 <code>'0'</code> 就是 <code>'1'</code>，都是真值，所以总是返回 <code>true</code>，应用会一直以为勾选了“记住我”。这正式测试能捕获的问题。</p>
<p>因为记住登录状态之前用户要先登录，所以我们首先要定义一个辅助方法，在测试中登入用户。在<a href="#listing-user-login-test-valid-information">代码清单 8.20</a> 中，我们使用 <code>post</code> 方法发送有效的 <code>session</code> 哈希，登入用户，但是每次都这么做有点麻烦。为了避免不必要的重复，我们要编写一个辅助方法，名为 <code>log_in_as</code>，登入用户。</p>
<p>登入用户的方法在不同类型的测试中有所不同，在集成测试中我们可以按照<a href="#listing-user-login-test-valid-information">代码清单 8.20</a> 中的方式向登录地址发送数据，但是在其他测试中，例如控制器和模型测试，这么做不行，我们要直接使用 <code>session</code> 方法。因此，<code>log_in_as</code> 要检测测试的类型，然后使用相应的处理方式。我们可以使用 Ruby 中的 <code>defined?</code> 方法区分集成测试和其他测试。如果定义了指定的参数，<code>defined?</code> 方法返回 <code>true</code>，否则返回 <code>false</code>。对现在的需求来说，<code>post_via_redirect</code> 方法只能在集成测试中使用，所以</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">defined?</span><span class="p">(</span><span class="n">post_via_redirect</span><span class="p">)</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</pre></div>
</div>
<p>在集成测试中返回 <code>true</code>，在其他类型的测试中返回 <code>false</code>。由此，我们可以定义一个名为 <code>integration_test?</code> 的方法，返回布尔值，然后使用 <code>if-else</code> 语句按照下面的方式编写代码：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="n">integration_test?</span>
  <span class="c1"># 向登录地址发送数据登入用户</span>
<span class="k">else</span>
  <span class="c1"># 使用 session 方法登入用户</span>
<span class="k">end</span>
</pre></div>
</div>
<p>把上面的注释换成代码后得到的 <code>log_in_as</code> 辅助方法如<a href="#listing-test-helper-log-in">代码清单 8.50</a> 所示。（这个方法相当高级，如果不能完全理解也没事。）</p>
<div id="listing-test-helper-log-in" data-type="listing">
<h5><span class="title-label">代码清单 8.50</span>：添加 <code>log_in_as</code> 辅助方法</h5>

<div class="source-file">test/test_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="no">ENV</span><span class="o">[</span><span class="s1">'RAILS_ENV'</span><span class="o">]</span> <span class="o">||=</span> <span class="s1">'test'</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="k">class</span> <span class="nc">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="n">fixtures</span> <span class="ss">:all</span>

  <span class="c1"># 如果用户已登录，返回 true</span>
  <span class="k">def</span> <span class="nf">is_logged_in?</span>
    <span class="o">!</span><span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">].</span><span class="n">nil?</span>
  <span class="k">end</span>

  <span class="c1"># 登入测试用户</span>
  <span class="k">def</span> <span class="nf">log_in_as</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">password</span>    <span class="o">=</span> <span class="n">options</span><span class="o">[</span><span class="ss">:password</span><span class="o">]</span>    <span class="o">||</span> <span class="s1">'password'</span>
    <span class="n">remember_me</span> <span class="o">=</span> <span class="n">options</span><span class="o">[</span><span class="ss">:remember_me</span><span class="o">]</span> <span class="o">||</span> <span class="s1">'1'</span>
<span class="hll">    <span class="k">if</span> <span class="n">integration_test?</span>
</span>      <span class="n">post</span> <span class="n">login_path</span><span class="p">,</span> <span class="ss">session</span><span class="p">:</span> <span class="p">{</span> <span class="ss">email</span><span class="p">:</span>       <span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="p">,</span>
                                  <span class="ss">password</span><span class="p">:</span>    <span class="n">password</span><span class="p">,</span>
                                  <span class="ss">remember_me</span><span class="p">:</span> <span class="n">remember_me</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>

    <span class="c1"># 在集成测试中返回 true</span>
    <span class="k">def</span> <span class="nf">integration_test?</span>
<span class="hll">      <span class="n">defined?</span><span class="p">(</span><span class="n">post_via_redirect</span><span class="p">)</span>
</span>    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>注意，为了实现最大的灵活性，<a href="#listing-test-helper-log-in">代码清单 8.50</a> 中的 <code>log_in_as</code> 方法有一个 <code>options</code> 哈希参数，而且为密码和“记住我”复选框设置了默认值，分别为 <code>'passowrd'</code> 和 <code>'1'</code>。因为哈希中未出现的键对应的值是 <code>nil</code>，所以：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">remember_me</span> <span class="o">=</span> <span class="n">options</span><span class="o">[</span><span class="ss">:remember_me</span><span class="o">]</span> <span class="o">||</span> <span class="s1">'1'</span>
</pre></div>
</div>
<p>如果传入了参数就使用指定的值，否则使用默认值（遵照<a href="#aside-or-equals">旁注 8.1</a> 中说明的短路计算法则）。</p>
<p>为了检查“记住我”复选框的行为，我们要编写两个测试，对应勾选和没勾选复选框两种情况。使用<a href="#listing-test-helper-log-in">代码清单 8.50</a> 中定义的登录辅助方法很容易实现，分别为：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">log_in_as</span><span class="p">(</span><span class="vi">@user</span><span class="p">,</span> <span class="ss">remember_me</span><span class="p">:</span> <span class="s1">'1'</span><span class="p">)</span>
</pre></div>
</div>
<p>和</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">log_in_as</span><span class="p">(</span><span class="vi">@user</span><span class="p">,</span> <span class="ss">remember_me</span><span class="p">:</span> <span class="s1">'0'</span><span class="p">)</span>
</pre></div>
</div>
<p>（因为 <code>remember_me</code> 的默认值是 <code>'1'</code>，所以第一种情况可以省略这个选项。不过我加上了，让两种情况的代码结构一致。）</p>
<p>登录后，我们可以检查 <code>cookies</code> 的 <code>remember_token</code> 键，确认有没有记住登录状态。理想情况下，我们可以检查 cookie 中的值是否等于用户的记忆令牌，但对目前的设计方式而言，在测试中行不通：控制器中的 <code>user</code> 变量有记忆令牌属性，但测试中的 <code>@user</code> 变量没有（因为 <code>remember_token</code> 是虚拟属性）。这个问题的修正方法留作<a href="#log-in-log-out-exercises">练习</a>。现在我们只测试 cookie 中相关的值是不是 <code>nil</code>。</p>
<p>不过，还有一个小问题，不知是什么原因，在测试中 <code>cookies</code> 方法不能使用符号键，所以：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span>
</pre></div>
</div>
<p>的值始终是 <code>nil</code>。幸好，<code>cookies</code> 可以使用字符串键，因此：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="n">cookies</span><span class="o">[</span><span class="s1">'remember_token'</span><span class="o">]</span>
</pre></div>
</div>
<p>可以获得我们所需的值。写出的测试如<a href="#listing-remember-me-test">代码清单 8.51</a> 所示。（<a href="#listing-user-login-test-valid-information">代码清单 8.20</a> 中用过 <code>users(:michael)</code>，它的作用是获取<a href="#listing-real-user-fixture">代码清单 8.19</a> 中的用户固件。）</p>
<div id="listing-remember-me-test" data-type="listing">
<h5><span class="title-label">代码清单 8.51</span>：测试“记住我”复选框 <span class="green">GREEN</span></h5>

<div class="source-file">test/integration/users_login_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">UsersLoginTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="n">users</span><span class="p">(</span><span class="ss">:michael</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="nb">test</span> <span class="s2">"login with remembering"</span> <span class="k">do</span>
<span class="hll">    <span class="n">log_in_as</span><span class="p">(</span><span class="vi">@user</span><span class="p">,</span> <span class="ss">remember_me</span><span class="p">:</span> <span class="s1">'1'</span><span class="p">)</span>
</span><span class="hll">    <span class="n">assert_not_nil</span> <span class="n">cookies</span><span class="o">[</span><span class="s1">'remember_token'</span><span class="o">]</span>
</span>  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"login without remembering"</span> <span class="k">do</span>
<span class="hll">    <span class="n">log_in_as</span><span class="p">(</span><span class="vi">@user</span><span class="p">,</span> <span class="ss">remember_me</span><span class="p">:</span> <span class="s1">'0'</span><span class="p">)</span>
</span><span class="hll">    <span class="n">assert_nil</span> <span class="n">cookies</span><span class="o">[</span><span class="s1">'remember_token'</span><span class="o">]</span>
</span>  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>如果你没犯我曾经犯过的错误，测试应该可以通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.52</span>：<strong class="green">GREEN</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
</section>
<section data-type="sect3" id="testing-the-remember-branch">
<h3>测试“记住”分支</h3>
<p>在<a href="#login-with-remembering">8.4.2 节</a>，我们自己动手确认了前面实现的持久会话可以正常使用，但是 <code>current_user</code> 方法的相关分支完全没有测试。针对这种情况，我最喜欢在未测试的代码块中抛出异常：如果没覆盖这部分代码，测试能通过；如果覆盖了，失败消息中会标识出相应的测试。如<a href="#listing-branch-raise">代码清单 8.53</a> 所示。</p>
<div id="listing-branch-raise" data-type="listing">
<h5><span class="title-label">代码清单 8.53</span>：在未测试的分支中抛出异常 <span class="green">GREEN</span></h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="c1"># 返回 cookie 中记忆令牌对应的用户</span>
  <span class="k">def</span> <span class="nf">current_user</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
      <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
<span class="hll">      <span class="k">raise</span>       <span class="c1"># 测试仍能通过，所以没有覆盖这个分支</span>
</span>      <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span><span class="p">)</span>
        <span class="n">log_in</span> <span class="n">user</span>
        <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在，测试应该可以通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.54</span>：<strong class="green">GREEN</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
<p>显然这是个问题，因为<a href="#listing-branch-raise">代码清单 8.53</a> 会导致应用无法正常使用。而且，手动测试持久会话很麻烦，所以，如果以后想重构 <code>current_user</code> 方法的话（<a href="chapter10.html#account-activation-and-password-reset">第 10 章</a>），现在就要测试。</p>
<p>因为<a href="#listing-test-helper-log-in">代码清单 8.50</a> 中的 <code>log_in_as</code> 辅助方法自动设定了 <code>session[:user_id]</code>，所以在集成测试中测试 <code>current_user</code> 方法的“记住”分支很难。不过，幸好我们可以跳过这个限制，在会话辅助方法的测试中直接测试 <code>current_user</code> 方法。我们要手动创建这个测试文件：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>touch <span class="nb">test</span>/helpers/sessions_helper_test.rb
</pre></div>
</div>
<p>测试的步骤很简单：</p>
<ol class="arabic">
<li>
<p>使用固件定义一个 <code>user</code> 变量；</p>
</li>
<li>
<p>调用 <code>remember</code> 方法记住这个用户；</p>
</li>
<li>
<p>确认 <code>current_user</code> 就是这个用户。</p>
</li>
</ol>
<p>因为 <code>remember</code> 方法没有设定 <code>session[:user_id]</code>，所以上述步骤能测试“记住”分支。测试如<a href="#listing-persistent-sessions-test">代码清单 8.55</a> 所示。</p>
<div id="listing-persistent-sessions-test" data-type="listing">
<h5><span class="title-label">代码清单 8.55</span>：测试持久会话</h5>

<div class="source-file">test/helpers/sessions_helper_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">SessionsHelperTest</span> <span class="o">&lt;</span> <span class="no">ActionView</span><span class="o">::</span><span class="no">TestCase</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="n">users</span><span class="p">(</span><span class="ss">:michael</span><span class="p">)</span>
    <span class="n">remember</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"current_user returns right user when session is nil"</span> <span class="k">do</span>
    <span class="n">assert_equal</span> <span class="vi">@user</span><span class="p">,</span> <span class="n">current_user</span>
    <span class="n">assert</span> <span class="n">is_logged_in?</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"current_user returns nil when remember digest is wrong"</span> <span class="k">do</span>
    <span class="vi">@user</span><span class="o">.</span><span class="n">update_attribute</span><span class="p">(</span><span class="ss">:remember_digest</span><span class="p">,</span> <span class="no">User</span><span class="o">.</span><span class="n">digest</span><span class="p">(</span><span class="no">User</span><span class="o">.</span><span class="n">new_token</span><span class="p">))</span>
    <span class="n">assert_nil</span> <span class="n">current_user</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>注意，我们还写了一个测试，确认如果记忆摘要和记忆令牌不匹配时当前用户是 <code>nil</code>，由此测试嵌套的 <code>if</code> 语句中 <code>authenticated?</code> 的表现：</p>
<div data-type="listing">


<div class="highlight language-ruby"><pre><span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>
<p><a href="#listing-persistent-sessions-test">代码清单 8.55</a> 中的测试应该失败：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.56</span>：<strong class="red">RED</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test </span><span class="nv">TEST</span><span class="o">=</span><span class="nb">test</span>/helpers/sessions_helper_test.rb
</pre></div>
</div>
<p>我们要删除 <code>raise</code>，把 <code>current_user</code> 方法恢复原样，如<a href="#listing-branch-no-raise">代码清单 8.57</a> 所示，这样测试就能通过了。（你还可以把<a href="#listing-branch-no-raise">代码清单 8.57</a> 中的 <code>authenticated?</code> 删除，看看<a href="#listing-persistent-sessions-test">代码清单 8.55</a> 中的测试是否失败，从而确认第二个测试编写的是否正确。）</p>
<div id="listing-branch-no-raise" data-type="listing">
<h5><span class="title-label">代码清单 8.57</span>：删除抛出异常的代码 <span class="green">GREEN</span></h5>

<div class="source-file">app/helpers/sessions_helper.rb</div>

<div class="highlight language-ruby"><pre><span class="k">module</span> <span class="nn">SessionsHelper</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="c1"># 返回 cookie 中记忆令牌对应的用户</span>
  <span class="k">def</span> <span class="nf">current_user</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">session</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
      <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
<span class="hll">    <span class="k">elsif</span> <span class="p">(</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">cookies</span><span class="o">.</span><span class="n">signed</span><span class="o">[</span><span class="ss">:user_id</span><span class="o">]</span><span class="p">)</span>
</span>      <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">authenticated?</span><span class="p">(</span><span class="n">cookies</span><span class="o">[</span><span class="ss">:remember_token</span><span class="o">]</span><span class="p">)</span>
        <span class="n">log_in</span> <span class="n">user</span>
        <span class="vi">@current_user</span> <span class="o">=</span> <span class="n">user</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<p>现在，测试组件应该可以通过：</p>
<div data-type="listing">
<h5><span class="title-label">代码清单 8.58</span>：<strong class="green">GREEN</strong></h5>


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>
</div>
<p>现在，<code>current_user</code> 方法中的“记住”分支有了测试，我们不用手动检查了，还且测试还能捕获回归。</p>
</section>
</section>
</section>
<section data-type="sect1" id="log-in-log-out-conclusion">
<h1><span class="title-label">8.5</span> 小结</h1>
<p>这两章我们介绍了很多基础知识，也为稍显简陋的应用实现了注册和登录功能。实现用户认证功能后，我们可以根据登录状态和用户的身份限制对特定页面的访问权限。我们会在<a href="chapter9.html#updating-showing-and-deleting-users">第 9 章</a>实现编辑用户个人信息的功能。</p>
<p>在继续之前，先把本章的改动合并到 <code>master</code> 分支：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
<span class="nv">$ </span>git add -A
<span class="nv">$ </span>git commit -m <span class="s2">"Finish log in/log out"</span>
<span class="nv">$ </span>git checkout master
<span class="nv">$ </span>git merge log-in-log-out
</pre></div>
</div>
<p>然后再推送到远程仓库和生产服务器：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>bundle <span class="nb">exec </span>rake <span class="nb">test</span>
<span class="nv">$ </span>git push
<span class="nv">$ </span>git push heroku
<span class="nv">$ </span>heroku run rake db:migrate
</pre></div>
</div>
<p>注意，推送后应用基本上处于不可用状态，不过执行迁移之后就没问题了。在拥有巨大流量的线上网站中，更新前最好开启<a href="https://devcenter.heroku.com/articles/maintenance-mode">维护模式</a>：</p>
<div data-type="listing">


<div class="highlight language-sh"><pre><span class="nv">$ </span>heroku maintenance:on
<span class="nv">$ </span>git push heroku
<span class="nv">$ </span>heroku run rake db:migrate
<span class="nv">$ </span>heroku maintenance:off
</pre></div>
</div>
<p>这样，在部署和执行迁移期间会显示一个标准的错误页面。详情参见 Heroku 文档中对<a href="https://devcenter.heroku.com/articles/error-pages">错误页面</a>的说明。</p>
<section data-type="sect2" id="log-in-log-out-learned">
<h2><span class="title-label">8.5.1</span> 读完本章学到了什么</h2>
<ul>
<li>
<p>Rails 可以使用临时 cookie 和持久 cookie 维护页面之间的状态；</p>
</li>
<li>
<p>登录表单的目的是创建新会话，登入用户；</p>
</li>
<li>
<p><code>flash.now</code> 方法用于在重新渲染的页面中显示闪现消息；</p>
</li>
<li>
<p>在测试中重现问题时可以使用测试驱动开发；</p>
</li>
<li>
<p>使用 <code>session</code> 方法可以安全地在浏览器中存储用户 ID，创建临时会话；</p>
</li>
<li>
<p>可以根据登录状态修改功能，例如布局中显示的链接；</p>
</li>
<li>
<p>集成测试可以检查路由、数据库更新和对布局的修改；</p>
</li>
<li>
<p>为了实现持久会话，我们为每个用户生成了记忆令牌和对应的记忆摘要；</p>
</li>
<li>
<p>使用 <code>cookies</code> 方法可以在浏览器的 cookie 中存储一个永久记忆令牌，实现持久会话；</p>
</li>
<li>
<p>登录状态取决于有没有当前用户，而当前用户通过临时会话中的用户 ID 或持久会话中唯一的记忆令牌获取；</p>
</li>
<li>
<p>退出功能通过删除会话中的用户 ID 和浏览器中的持久 cookie 实现；</p>
</li>
<li>
<p>三元操作符是编写简单 <code>if-else</code> 语句的简洁方式。</p>
</li>
</ul>
</section>
</section>
<section data-type="sect1" id="log-in-log-out-exercises">
<h1><span class="title-label">8.6</span> 练习</h1>
<p>避免练习和正文冲突的方法参见<a href="chapter3.html#mostly-static-pages-exercises">3.6 节</a>中的说明。</p>
<ol class="arabic">
<li>
<p>在<a href="#listing-user-model-remember">代码清单 8.32</a> 中，我们定义了生成令牌和摘要的类方法，前面都加上了 <code>User</code>。这么定义没问题，而且因为我们会使用 <code>User.new_token</code> 和 <code>User.digest</code> 调用，或许这样定义意思更明确。不过，定义类方法有两种更常用的方式，一种有点让人困惑，一种极其让人困惑。运行测试组件，确认<a href="#listing-token-digest-self">代码清单 8.59</a>（有点让人困惑）和<a href="#listing-token-digest-class-self">代码清单 8.60</a>（极其让人困惑）中的实现方式是正确的。（注意，在<a href="#listing-token-digest-self">代码清单 8.59</a> 和<a href="#listing-token-digest-class-self">代码清单 8.60</a> 中，<code>self</code> 是 <code>User</code> 类，而用户模型中的其他 <code>self</code> 都是用户对象实例。这就是让人困惑的根源所在。）</p>
</li>
<li>
<p><a href="#remember-me-checkbox">8.4.5 节</a>说过，由于应用现在的设计方式，在<a href="#listing-remember-me-test">代码清单 8.51</a> 的集成测试中无法获取 <code>remember_token</code> 虚拟属性。不过，在测试中使用一个特殊的方法可以获取，这个方法是 <code>assigns</code>。在测试中，可以访问控制器中定义的实例变量，方法是把实例变量的符号形式传给 <code>assigns</code> 方法。例如，如果 <code>create</code> 动作中定义了 <code>@user</code> 变量，在测试中可以使用 <code>assigns(:user)</code> 获取这个变量。现在，会话控制器中的 <code>create</code> 动作定义了一个普通的变量（不是实例变量），名为 <code>user</code>，如果我们把它改成实例变量，就可以测试 <code>cookies</code> 中是否包含用户的记忆令牌。填写<a href="#listing-login-create-user-instance">代码清单 8.61</a> 和<a href="#listing-improved-remember-me-test">代码清单 8.62</a> 中缺少的内容（<code>?</code> 和 <code>FILL_IN</code>），完成改进后的“记住我”复选框测试。</p>
</li>
</ol>
<div id="listing-token-digest-self" data-type="listing">
<h5><span class="title-label">代码清单 8.59</span>：使用 <code>self</code> 定义生成令牌和摘要的方法 <span class="green">GREEN</span></h5>

<div class="source-file">app/models/user.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="c1"># 返回指定字符串的哈希摘要</span>
<span class="hll">  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">digest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span>    <span class="n">cost</span> <span class="o">=</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">SecurePassword</span><span class="o">.</span><span class="n">min_cost</span> <span class="p">?</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">::</span><span class="no">MIN_COST</span> <span class="p">:</span>
                                                  <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">.</span><span class="n">cost</span>
    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="ss">cost</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># 返回一个随机令牌</span>
<span class="hll">  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new_token</span>
</span>    <span class="no">SecureRandom</span><span class="o">.</span><span class="n">urlsafe_base64</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
<div id="listing-token-digest-class-self" data-type="listing">
<h5><span class="title-label">代码清单 8.60</span>：使用 <code>class &lt;&lt; self</code> 定义生成令牌和摘要的方法 <span class="green">GREEN</span></h5>

<div class="source-file">app/models/user.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="hll">  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
</span>    <span class="c1"># 返回指定字符串的哈希摘要</span>
<span class="hll">    <span class="k">def</span> <span class="nf">digest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span>      <span class="n">cost</span> <span class="o">=</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">SecurePassword</span><span class="o">.</span><span class="n">min_cost</span> <span class="p">?</span> <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">::</span><span class="no">MIN_COST</span> <span class="p">:</span>
                                                    <span class="no">BCrypt</span><span class="o">::</span><span class="no">Engine</span><span class="o">.</span><span class="n">cost</span>
      <span class="no">BCrypt</span><span class="o">::</span><span class="no">Password</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="ss">cost</span><span class="p">:</span> <span class="n">cost</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># 返回一个随机令牌</span>
<span class="hll">    <span class="k">def</span> <span class="nf">new_token</span>
</span>      <span class="no">SecureRandom</span><span class="o">.</span><span class="n">urlsafe_base64</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
</pre></div>
</div>
<div id="listing-login-create-user-instance" data-type="listing">
<h5><span class="title-label">代码清单 8.61</span>：在 <code>create</code> 动作中使用实例变量的模板</h5>

<div class="source-file">app/controllers/sessions_controller.rb</div>

<div class="highlight language-ruby"><pre><span class="k">class</span> <span class="nc">SessionsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">create</span>
<span class="hll">    <span class="p">?</span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by</span><span class="p">(</span><span class="ss">email</span><span class="p">:</span> <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:email</span><span class="o">].</span><span class="n">downcase</span><span class="p">)</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">?</span><span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="p">?</span><span class="n">user</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
</span><span class="hll">      <span class="n">log_in</span> <span class="p">?</span><span class="n">user</span>
</span><span class="hll">      <span class="n">params</span><span class="o">[</span><span class="ss">:session</span><span class="o">][</span><span class="ss">:remember_me</span><span class="o">]</span> <span class="o">==</span> <span class="s1">'1'</span> <span class="p">?</span> <span class="n">remember</span><span class="p">(?</span><span class="n">user</span><span class="p">)</span> <span class="p">:</span> <span class="n">forget</span><span class="p">(?</span><span class="n">user</span><span class="p">)</span>
</span><span class="hll">      <span class="n">redirect_to</span> <span class="p">?</span><span class="n">user</span>
</span>    <span class="k">else</span>
      <span class="n">flash</span><span class="o">.</span><span class="n">now</span><span class="o">[</span><span class="ss">:danger</span><span class="o">]</span> <span class="o">=</span> <span class="s1">'Invalid email/password combination'</span>
      <span class="n">render</span> <span class="s1">'new'</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">destroy</span>
    <span class="n">log_out</span> <span class="k">if</span> <span class="n">logged_in?</span>
    <span class="n">redirect_to</span> <span class="n">root_url</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<div id="listing-improved-remember-me-test" data-type="listing">
<h5><span class="title-label">代码清单 8.62</span>：改进后的“记住我”复选框测试模板 <span class="green">GREEN</span></h5>

<div class="source-file">test/integration/users_login_test.rb</div>

<div class="highlight language-ruby"><pre><span class="nb">require</span> <span class="s1">'test_helper'</span>

<span class="k">class</span> <span class="nc">UsersLoginTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="n">users</span><span class="p">(</span><span class="ss">:michael</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="nb">test</span> <span class="s2">"login with remembering"</span> <span class="k">do</span>
    <span class="n">log_in_as</span><span class="p">(</span><span class="vi">@user</span><span class="p">,</span> <span class="ss">remember_me</span><span class="p">:</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="hll">    <span class="n">assert_equal</span> <span class="n">assigns</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span><span class="o">.</span><span class="n">FILL_IN</span><span class="p">,</span> <span class="no">FILL_IN</span>
</span>  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"login without remembering"</span> <span class="k">do</span>
    <span class="n">log_in_as</span><span class="p">(</span><span class="vi">@user</span><span class="p">,</span> <span class="ss">remember_me</span><span class="p">:</span> <span class="s1">'0'</span><span class="p">)</span>
    <span class="n">assert_nil</span> <span class="n">cookies</span><span class="o">[</span><span class="s1">'remember_token'</span><span class="o">]</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>
</section>
</section>
                </article>

                <div class="navi clearfix">
                    
                        <div class="pull-left">
                            <a class="prev" href="chapter7.html" title="第 7 章 注册">&laquo; 第 7 章 注册</a>
                        </div>
                    
                    
                        <div class="pull-right">
                            <a class="next" href="chapter9.html" title="第 9 章 更新，显示和删除用户">第 9 章 更新，显示和删除用户 &raquo; </a>
                        </div>
                    
                </div>

                <div class="footnotes">
<ol>
<li id="fn-1">还有一种常见的实现方式：一定时间后让会话失效。包含敏感数据的网站特别适合使用这种方式，例如银行和金融交易账户。 <a href="#fn-ref-1">&#8617;</a></li>
<li id="fn-2">有些浏览器提供了恢复这种会话的功能，可以继续使用离开时的状态。当然，Rails 不会禁止使用这种功能。 <a href="#fn-ref-2">&#8617;</a></li>
<li id="fn-3">另一种方法是不用 <code>form_for</code>，换用 <code>form_tag</code>，这样更符合 Rails 的习惯。不过，换用 <code>form_tag</code> 后，登录表单和注册表单的共同点就少了，现阶段我想强调二者之间的共通结构。 <a href="#fn-ref-3">&#8617;</a></li>
<li id="fn-4">因为<a href="#listing-sessions-helper-include">代码清单 8.11</a> 引入了辅助方法模块，所以在会话控制器中可以使用 <code>log_in</code> 方法。 <a href="#fn-ref-4">&#8617;</a></li>
<li id="fn-5">在多次方法调用之间记住返回值的方式叫“<a href="http://en.wikipedia.org/wiki/Memoization">备忘</a>”（memoization）。（注意，这是一个技术术语，不是“memorization”的错误写法。） <a href="#fn-ref-5">&#8617;</a></li>
<li id="fn-6">译者注：这里对 <code>||=</code> 的分析和 Peter Cooper 的分析有点差异，推荐你看一下 Ruby Inside 中的《<a href="http://www.rubyinside.com/what-rubys-double-pipe-or-equals-really-does-5488.html">What Ruby’s ||= (Double Pipe / Or Equals) Really Does</a>》一文。 <a href="#fn-ref-6">&#8617;</a></li>
<li id="fn-7">头像出处：http://www.flickr.com/photos/hermanusbackpackers/3343254977/ <a href="#fn-ref-7">&#8617;</a></li>
<li id="fn-8">Web 浏览器其实不能发送 <code>DELETE</code> 请求，Rails 使用 JavaScript 模拟实现。 <a href="#fn-ref-8">&#8617;</a></li>
<li id="fn-9">详情参见 <a href="http://getbootstrap.com/components/">Bootstrap 组件文档</a>。 <a href="#fn-ref-9">&#8617;</a></li>
<li id="fn-10">如果使用云端 IDE，建议你使用另一个浏览器测试登录表现，这样就不用关闭运行云端 IDE 的浏览器了。 <a href="#fn-ref-10">&#8617;</a></li>
<li id="fn-11">因为在<a href="#listing-sessions-helper-include">代码清单 8.11</a> 中引入了辅助方法模块，所以用户控制器和会话控制器一样，也可以调用 <code>log_in</code> 方法。 <a href="#fn-ref-11">&#8617;</a></li>
<li id="fn-12">有一次我不小心把会话辅助方法 <code>log_in</code> 删掉了，但是测试组件仍能通过，因为测试中使用了同名辅助方法，就算应用完全不能运行了，测试还是可以通过。和 <code>is_logged_in?</code> 一样，为了避免这种问题，<a href="#listing-test-helper-log-in">代码清单 8.50</a> 中还会定义一个名为 <code>log_in_as</code> 的测试辅助方法。 <a href="#fn-ref-12">&#8617;</a></li>
<li id="fn-13">如果在执行 <code>destroy</code> 动作之前创建了 <code>@current_user</code>（这里没有创建），或者没有立即重定向，就要把 <code>@current_user</code> 设为 <code>nil</code>（这里立即重定向了）。这两种情况不可能同时发生，而且根据这个应用目前的架构，也没必要这么做。不过这涉及到安全问题，所以以防万一，我在这里把当前用户设为了 <code>nil</code>。 <a href="#fn-ref-13">&#8617;</a></li>
<li id="fn-14">会话劫持大都可由 <a href="http://codebutler.com/firesheep">Firesheep</a> 应用发现。连接公共 WIFI 时，使用这个应用能看到很多知名网站的记忆令牌。 <a href="#fn-ref-14">&#8617;</a></li>
<li id="fn-15">之所以使用这个方法，是因为我看了 <a href="http://railscasts.com/episodes/274-remember-me-reset-password">RailsCast 中对记住我功能的介绍</a>。 <a href="#fn-ref-15">&#8617;</a></li>
<li id="fn-16">何止“可以”，因为 bcrypt 会在哈希值中<a href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29">加盐</a>，其实没有办法判别两个用户的密码是否相同。 <a href="#fn-ref-16">&#8617;</a></li>
<li id="fn-17">如果记忆令牌是唯一的，攻击者必须同时拥有用户的 ID 和 cookie 中的记忆令牌才能劫持会话。 <a href="#fn-ref-17">&#8617;</a></li>
<li id="fn-18">一般的规则是，如果方法不需要访问类的实例，就应该定义为类方法。到 <a href="chapter10.html#account-activation-mailer-method">10.1.2 节</a>会发现，这个决定很重要。 <a href="#fn-ref-18">&#8617;</a></li>
<li id="fn-19"><a href="chapter6.html#a-hashed-password">6.3.1 节</a>说过，“unencrypted password”（未加密的密码）用词不当，因为安全密码是哈希值，并不是加密后得到的值。 <a href="#fn-ref-19">&#8617;</a></li>
<li id="fn-20">我一般会把这种赋值语句放在括号内，从视觉上提醒自己，这不是比较。 <a href="#fn-ref-20">&#8617;</a></li>
<li id="fn-21">若想知道怎么在你的系统中查看 cookie，请在谷歌中搜索“&lt;你的浏览器名&gt; inspect cookies”。 <a href="#fn-ref-21">&#8617;</a></li>
<li id="fn-22">感谢读者 Paulo Célio Júnior 指出这个问题。 <a href="#fn-ref-22">&#8617;</a></li>
<li id="fn-23">感谢读者 Niels de Ron 指出这个问题。 <a href="#fn-ref-23">&#8617;</a></li>
<li id="fn-24">前面我们写成 <code>remember user</code>，没有括号，但是在三元操作符中，如果不加括号会导致句法错误。 <a href="#fn-ref-24">&#8617;</a></li>
</ol>
</div>
            </div>
        </div>
    </div>
</div>

<footer class="footer">
    <p>&copy;2013-2015 <a href="http://about.ac" title="安道的网站">安道</a></p>
    <p class="sns"><a href="https://twitter.com/andor_chen" title="安道的 Twitter"><i class="fa fa-twitter"></i></a> <a href="http://weibo.com/andor27" title="安道的微博"><i class="fa fa-weibo"></i></a></p>
    <p>保留部分权利，禁止转载</p>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56255794-2', 'auto');
  ga('send', 'pageview');
  $('#navbar-purchase').on('click',function(){
    ga('send', 'event', 'button', 'click', 'navbar purchase');
  });
  $('#navbar-purchase-xs').on('click',function(){
    ga('send', 'event', 'button', 'click', 'navbar purchase xs');
  });
</script>

</body>
</html>
